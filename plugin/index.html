<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AutoPlan Settings</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      margin: 0;
      padding: 20px;
      color: var(--text-color);
    }

    h1 {
      font-size: 14px;
      margin: 0 0 4px 0;
    }

    .subtitle {
      font-size: 14px;
      opacity: 0.7;
      margin-bottom: 20px;
    }

    .section {
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--separator-color);
    }

    .section:last-of-type {
      border-bottom: none;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    label {
      display: block;
      font-size: 0.9em;
      opacity: 0.7;
      margin-bottom: 4px;
    }

    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 8px;
      font-size: inherit;
      font-family: inherit;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .checkbox-group label {
      margin-bottom: 0;
      opacity: 1;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .help-text {
      font-size: 0.8em;
      opacity: 0.6;
      margin-top: 4px;
    }

    .section-description {
      font-size: 0.9em;
      opacity: 0.7;
      margin-bottom: 12px;
    }

    /* Intro section */
    .intro-section {
      margin-bottom: 20px;
    }

    .how-it-works {
      margin-bottom: 12px;
    }

    .how-it-works summary {
      cursor: pointer;
      font-weight: 500;
      opacity: 0.8;
      padding: 8px 0;
      user-select: none;
    }

    .how-it-works summary:hover {
      opacity: 1;
    }

    /* When closed, show greyed out text */
    .how-it-works:not([open]) summary {
      color: #888 !important;
      font-weight: normal;
    }

    /* When open, restore normal styling */
    .how-it-works[open] summary {
      font-weight: 500;
    }

    .intro-content {
      padding: 12px;
      background: rgba(128, 128, 128, 0.1);
      border-radius: 4px;
      margin-top: 8px;
    }

    .intro-content ol {
      padding-left: 20px;
      margin: 12px 0;
    }

    .intro-content li {
      margin-bottom: 8px;
    }

    .tip-box {
      padding: 12px;
      background: rgba(124, 77, 255, 0.1);
      border-left: 3px solid var(--c-primary, #7c4dff);
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .tip-box p {
      margin: 8px 0 0 0;
      font-size: 0.9em;
      opacity: 0.85;
    }

    .tip-box strong {
      display: block;
      margin-bottom: 4px;
    }

    /* Tag Priorities Table */
    .tag-table {
      width: 100%;
      border-collapse: collapse;
    }

    .tag-table th,
    .tag-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid var(--separator-color);
    }

    .tag-table th {
      font-weight: 600;
      font-size: 0.8em;
      text-transform: uppercase;
      opacity: 0.7;
    }

    .tag-table input {
      width: 80px;
    }

    .tag-badge {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--separator-color);
      border-radius: 12px;
      font-size: 0.85em;
    }

    .add-tag-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .add-tag-row input {
      flex: 1;
    }

    /* Buttons */
    .btn {
      padding: 8px 16px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      font-size: inherit;
      font-family: inherit;
      cursor: pointer;
      background: transparent;
      color: var(--text-color);
    }

    .btn:hover {
      opacity: 0.8;
    }

    .btn-primary {
      background: var(--c-primary, #7c4dff);
      border: 2px solid var(--c-primary, #7c4dff);
      color: var(--c-primary-contrast, #ffffff);
    }

    .btn-primary:hover {
      opacity: 0.9;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .btn-small {
      padding: 4px 10px;
      font-size: 0.85em;
    }

    .actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    /* Schedule Preview */
    .schedule-preview {
      max-height: 400px;
      overflow-y: auto;
    }

    .schedule-item {
      display: flex;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--separator-color);
    }

    .schedule-item:last-child {
      border-bottom: none;
    }

    .schedule-title {
      flex: 1;
      margin-right: 16px;
    }

    .schedule-urgency {
      font-size: 0.85em;
      padding: 2px 8px;
      border: 1px solid var(--separator-color);
      border-radius: 10px;
      white-space: nowrap;
    }

    /* Status Messages */
    .status {
      padding: 10px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      margin-bottom: 16px;
      display: none;
    }

    .status.show {
      display: block;
    }

    .status.warning {
      background: rgba(255, 152, 0, 0.1);
      border-color: #ff9800;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 40px;
      opacity: 0.7;
    }

    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid var(--separator-color);
      border-top-color: var(--c-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--separator-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .tab {
      padding: 10px 16px;
      cursor: pointer;
      opacity: 0.6;
      border-bottom: 2px solid transparent;
    }

    .tab:hover {
      opacity: 0.9;
    }

    .tab.active {
      opacity: 1;
      border-bottom-color: var(--c-primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Formula editor */
    .formula-preview {
      padding: 10px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
      margin-top: 8px;
      opacity: 0.8;
    }

    /* Run AutoPlan Section */
    .run-section {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--separator-color, #e0e0e0);
    }

    .btn-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--c-primary-contrast);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Priority List */
    .priority-item {
      padding: 10px 0;
      border-bottom: 1px solid var(--separator-color);
    }

    .priority-item:last-child {
      border-bottom: none;
    }

    .priority-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .priority-title {
      flex: 1;
      font-weight: 500;
    }

    .priority-score {
      font-size: 0.9em;
      font-weight: 600;
      padding: 4px 10px;
      background: var(--c-primary, #7c4dff);
      color: var(--c-primary-contrast, #ffffff);
      border-radius: 12px;
      white-space: nowrap;
    }

    .priority-explanation {
      font-size: 0.8em;
      opacity: 0.5;
      margin-top: 4px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>AutoPlan</h1>
  <p class="subtitle">Automatic task scheduling based on priority and urgency</p>

  <div id="status" class="status"></div>

  <!-- Action Buttons Section -->
  <div class="run-section">
    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
      <button class="btn btn-primary" style="flex: 1;" onclick="handleDryRun()">
        üîç Dry Run
      </button>
      <button class="btn btn-primary" style="flex: 1;" id="applyButton" onclick="handleApplySchedule()">
        <span id="applyButtonContent">‚ö° Apply Schedule</span>
      </button>
    </div>
  </div>

  <!-- Priority List Section (First Screen) -->
  <div class="section">
    <div class="section-title">Task Priorities</div>
    <p class="section-description">
      Tasks sorted by their computed priority score. Higher priority tasks are scheduled first.
    </p>
    
    <button class="btn" onclick="loadTaskPriorities()">
      üîÑ Refresh Priorities
    </button>

    <div id="prioritiesList" style="margin-top: 16px;">
      <div class="loading"><div class="spinner"></div>Loading task priorities...</div>
    </div>
  </div>

  <!-- Tabs for Settings -->
  <div class="tabs">
    <div class="tab active" data-tab="tags-priorities">Setting tags and priorities</div>
    <div class="tab" data-tab="formulas">Setting formulas</div>
    <div class="tab" data-tab="other-settings">Other settings</div>
    <div class="tab" data-tab="merge">Manage Split Tasks</div>
  </div>

  <!-- Setting tags and priorities Tab -->
  <div id="tab-tags-priorities" class="tab-content active">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How Tags and Project Priorities Work</strong></p>
        <p>When a task has a tag or belongs to a project listed here, that boost value is added to its total priority score. Tasks with higher priority get scheduled earlier.</p>
        <p><strong>Examples:</strong></p>
        <ul>
          <li>Add +20 to "Urgent" tag to schedule urgent tasks sooner</li>
          <li>Add -10 to "Low Priority" to push those tasks later</li>
          <li>Add +15 to "Work" project to prioritize work tasks</li>
        </ul>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Tag Priority Boosts</div>
      <p class="section-description">
        Give certain types of tasks higher or lower priority based on their tags.
      </p>
      
      <table class="tag-table" id="tagTable">
        <thead>
          <tr>
            <th>Tag Name</th>
            <th>Priority Boost</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="tagTableBody">
          <!-- Tags will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newTagName">
          <option value="">Select a tag...</option>
        </select>
        <input type="number" id="newTagPriority" placeholder="Boost" value="10" style="width: 80px;">
        <button class="btn btn-small" onclick="addTagPriority()">Add Tag</button>
      </div>
      <p class="help-text">Select a tag from the dropdown to add a priority boost.</p>
    </div>

    <div class="section">
      <div class="section-title">Project Priority Boosts</div>
      <p class="section-description">
        Give tasks in certain projects higher or lower priority.
      </p>
      
      <table class="tag-table" id="projectTable">
        <thead>
          <tr>
            <th>Project Name</th>
            <th>Priority Boost</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="projectTableBody">
          <!-- Projects will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newProjectName">
          <option value="">Select a project...</option>
        </select>
        <input type="number" id="newProjectPriority" placeholder="Boost" value="10" style="width: 80px;">
        <button class="btn btn-small" onclick="addProjectPriority()">Add Project</button>
      </div>
      <p class="help-text">Select a project from the dropdown to add a priority boost.</p>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Setting formulas Tab -->
  <div id="tab-formulas" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>Understanding Priority Formulas</strong></p>
        <p>These formulas add bonus priority based on task characteristics. The weight controls how much influence each factor has on the final priority score.</p>
        <p><strong>Duration Priority:</strong> Should shorter or longer tasks be prioritized?</p>
        <p><strong>Oldness Priority:</strong> Should older tasks be prioritized to prevent them from being forgotten?</p>
        <p><strong>Total Formula:</strong> Total Priority = Tag Boosts + Project Boosts + Duration Factor + Oldness Factor</p>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Duration Priority Formula</div>
      <p class="section-description">
        Should shorter or longer tasks be prioritized?
      </p>
      
      <div class="row">
        <div class="form-group">
          <label for="durationFormula">Formula Type</label>
          <select id="durationFormula">
            <option value="none">None (duration doesn't affect priority)</option>
            <option value="linear">Linear - longer tasks = higher priority</option>
            <option value="inverse">Inverse - shorter tasks = higher priority</option>
            <option value="log">Logarithmic - moderate effect, diminishing returns</option>
          </select>
        </div>
        <div class="form-group">
          <label for="durationWeight">Weight (0-10)</label>
          <input type="number" id="durationWeight" min="0" max="10" step="0.1" value="1.0">
          <p class="help-text">Higher = stronger effect. Set to 0 to disable.</p>
        </div>
      </div>

      <div class="formula-preview" id="durationPreview">
        Duration Priority = linear(hours) * 1.0
      </div>
    </div>

    <div class="section">
      <div class="section-title">Oldness Priority Formula</div>
      <p class="section-description">
        Should older tasks be prioritized to prevent them from being forgotten?
      </p>
      
      <div class="row">
        <div class="form-group">
          <label for="oldnessFormula">Formula Type</label>
          <select id="oldnessFormula">
            <option value="none">None (age doesn't affect priority)</option>
            <option value="linear">Linear - priority grows steadily with age</option>
            <option value="log">Logarithmic - quick initial boost, then levels off</option>
            <option value="exponential">Exponential - old tasks become very urgent</option>
          </select>
        </div>
        <div class="form-group">
          <label for="oldnessWeight">Weight (0-10)</label>
          <input type="number" id="oldnessWeight" min="0" max="10" step="0.1" value="1.0">
          <p class="help-text">Higher = stronger effect. Set to 0 to disable.</p>
        </div>
      </div>

      <div class="formula-preview" id="oldnessPreview">
        Oldness Priority = linear(days) * 1.0
      </div>
    </div>

    <div class="section">
      <div class="section-title">Total Priority Formula</div>
      <p class="section-description">The final priority score combines all factors:</p>
      <div class="formula-preview">
        Total Priority = Tag Boosts + Project Boosts + Duration Factor + Oldness Factor
      </div>
      <p class="help-text" style="margin-top: 8px;">
        Tasks with higher total priority get scheduled first.
      </p>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Other settings Tab -->
  <div id="tab-other-settings" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How AutoPlan Works</strong></p>
        <p>AutoPlan automatically schedules your tasks by splitting them into time blocks and assigning them to your calendar based on calculated urgency.</p>
        <ol>
          <li><strong>Priority Calculation:</strong> Each task gets a priority score based on tags, projects, duration, and age</li>
          <li><strong>Task Splitting:</strong> Large tasks are split into manageable time blocks (e.g., 2-hour chunks)</li>
          <li><strong>Smart Scheduling:</strong> Blocks are scheduled iteratively - the most urgent task gets the next available slot, then priorities are recalculated</li>
          <li><strong>Calendar Integration:</strong> Scheduled blocks appear in your Super Productivity timeline</li>
        </ol>
        <p><strong>Requirements:</strong> Tasks must have a time estimate to be scheduled. Tasks without estimates are skipped.</p>
      </div>
    </details>
    
    <div class="section">
    <div class="section">
      <div class="section-title">Block Settings</div>
      <p class="section-description">Control how tasks are divided into schedulable time blocks.</p>
      
      <div class="form-group">
        <label for="blockSize">Block Size (minutes)</label>
        <input type="number" id="blockSize" min="15" max="480" step="15" value="120">
        <p class="help-text">Large tasks are split into blocks of this duration. Example: A 6-hour task with 120-minute blocks becomes 3 separate 2-hour blocks that can be scheduled on different days.</p>
      </div>

      <div class="row">
        <div class="form-group">
          <label for="maxDays">Planning Horizon (days)</label>
          <input type="number" id="maxDays" min="1" max="365" value="30">
          <p class="help-text">How far ahead to schedule tasks. Tasks won't be scheduled beyond this many days from today.</p>
        </div>
        <div class="form-group">
          <div class="checkbox-group" style="margin-top: 28px;">
            <input type="checkbox" id="autoRun">
            <label for="autoRun">Auto-run on startup</label>
          </div>
          <p class="help-text">Automatically reschedule all tasks when Super Productivity starts.</p>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Task Splitting</div>
      <p class="section-description">Configure how split tasks are named.</p>
      
      <div class="form-group">
        <div class="checkbox-group">
          <input type="checkbox" id="splitSuffix" checked>
          <label for="splitSuffix">Add Roman numeral suffix (&lt;I&gt;, &lt;II&gt;, &lt;III&gt;...)</label>
        </div>
        <p class="help-text">When enabled, split tasks are named "Task Name &lt;I&gt;", "Task Name &lt;II&gt;", etc. When disabled, all splits keep the original task name.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Fixed Tasks (Do Not Reschedule)</div>
      <p class="section-description">Some tasks have fixed times (meetings, appointments) and shouldn't be moved by AutoPlan.</p>
      
      <div class="form-group">
        <label for="doNotRescheduleTag">Do Not Reschedule Tag</label>
        <select id="doNotRescheduleTag">
          <option value="">(None - reschedule all tasks)</option>
          <!-- Tags will be populated dynamically -->
        </select>
        <p class="help-text">Tasks with this tag will keep their existing schedule and won't be rescheduled. Their time is subtracted from available hours on those days, so other tasks schedule around them.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Work Schedule</div>
      <p class="section-description">Define your available working hours. Tasks will only be scheduled during these times.</p>
      
      <div class="row">
        <div class="form-group">
          <label for="workdayStartHour">Workday Start Hour (0-23)</label>
          <input type="number" id="workdayStartHour" min="0" max="23" value="9">
          <p class="help-text">Hour when your workday begins (24-hour format). Example: 9 = 9:00 AM</p>
        </div>
        <div class="form-group">
          <label for="workdayHours">Workday Length (hours)</label>
          <input type="number" id="workdayHours" min="1" max="24" value="8">
          <p class="help-text">How many hours you work per day. Example: 8 hours starting at 9 AM = work until 5 PM</p>
        </div>
      </div>

      <div class="form-group">
        <label>Days Off</label>
        <p class="help-text" style="margin-bottom: 8px;">Select days when no tasks should be scheduled (weekends, rest days, etc.)</p>
        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay0" checked>
            <span>Sunday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay1">
            <span>Monday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay2">
            <span>Tuesday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay3">
            <span>Wednesday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay4">
            <span>Thursday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay5">
            <span>Friday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay6" checked>
            <span>Saturday</span>
          </label>
        </div>
      </div>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Manage Split Tasks Tab -->
  <div id="tab-merge" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How Merging Works</strong></p>
        <p>When AutoPlan splits a task into multiple blocks, you can merge them back together here.</p>
        <ul>
          <li><strong>Incomplete splits</strong> are combined into one task</li>
          <li><strong>Time estimates</strong> from all splits are summed together</li>
          <li><strong>The original title</strong> is restored (Roman numerals removed)</li>
          <li><strong>Completed splits</strong> are deleted (their work is already done)</li>
        </ul>
        <p>Use this when you want to reschedule a task differently, or if you finished the work faster than expected.</p>
        <p><strong>What happens when you "Clear All Planning":</strong></p>
        <ul>
          <li>All split tasks (e.g., "Task &lt;I&gt;", "Task &lt;II&gt;") are merged back into single tasks</li>
          <li>Scheduled times are removed from tasks with time estimates (except those with "Do Not Reschedule" tag)</li>
        </ul>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Split Task Groups</div>
      <p class="section-description">
        When AutoPlan splits a task into multiple blocks, you can merge them back together here.
      </p>
      
      <button class="btn" onclick="loadSplitGroups()">
        üîÑ Refresh Split Groups
      </button>

      <div id="splitGroups" style="margin-top: 16px;">
        <p style="opacity: 0.7;">Click "Refresh Split Groups" to load split task groups.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Clear Planning</div>
      <p class="section-description">
        Merge all split tasks back together and remove scheduled times, without rescheduling.
      </p>
      
      <button class="btn" onclick="handleClearPlanning()">
        Clear All Planning
      </button>
    </div>
  </div>

  <script>
    // State
    let currentConfig = {};
    let availableTags = [];
    let availableProjects = [];

    // Handle Dry Run button click
    async function handleDryRun() {
      try {
        // Save current settings first
        await saveSettings();

        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(true);
          const schedule = result.schedule || [];
          showStatus(`Dry Run complete: ${schedule.length} blocks would be scheduled`, 'info');
        } else {
          // AutoPlanAPI not available
          showStatus('AutoPlanAPI not available. Use the header button or Ctrl+Shift+A to run.', 'info');
        }
      } catch (e) {
        console.error('Dry run failed:', e);
        showStatus('Dry run failed: ' + e.message, 'error');
      }
    }

    // Handle Apply Schedule button click
    async function handleApplySchedule() {
      const button = document.getElementById('applyButton');
      const buttonContent = document.getElementById('applyButtonContent');
      const originalContent = buttonContent.innerHTML;

      // Show loading state
      button.disabled = true;
      buttonContent.innerHTML = '<span class="btn-spinner"></span> Running...';

      try {
        // Save current settings first
        await saveSettings();

        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(false);
          const schedule = result.schedule || [];
          
          // Check for priority vs schedule order discrepancies (deadline-based)
          const priorityComparison = await calculatePriorityComparison(schedule);
          
          if (priorityComparison.warnings.length > 0) {
            const deadlineTasks = priorityComparison.warnings
              .map(w => `${w.title} (${w.deadline.toLocaleDateString()})`)
              .join(', ');
            showStatus(
              `AutoPlan complete: ${schedule.length} blocks scheduled. ` +
              `Deadline priority applied: ${deadlineTasks}`,
              'warning'
            );
          } else {
            showStatus(`AutoPlan complete: ${schedule.length} blocks scheduled`, 'success');
          }
          
          // Refresh the priority list
          await loadTaskPriorities();
        } else {
          // AutoPlanAPI not available
          showStatus('AutoPlanAPI not available. Use the header button or Ctrl+Shift+A to run.', 'info');
        }
      } catch (e) {
        console.error('AutoPlan failed:', e);
        showStatus('AutoPlan failed: ' + e.message, 'error');
      } finally {
        // Restore button state
        button.disabled = false;
        buttonContent.innerHTML = originalContent;
      }
    }

    // Handle Run AutoPlan button click (legacy - kept for compatibility)
    async function handleRunAutoplan() {
      return handleApplySchedule();
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
      });
    });

    // Show status message
    function showStatus(message, type = 'info') {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status show ${type}`;
      setTimeout(() => {
        status.classList.remove('show');
      }, 3000);
    }

    // Load settings from plugin
    async function loadSettings() {
      try {
        const data = await PluginAPI.loadSyncedData();
        if (data) {
          currentConfig = JSON.parse(data);
        } else {
          currentConfig = getDefaultConfig();
        }
        // Populate dropdowns before applying settings
        await populateTagDropdown();
        await populateProjectDropdown();
        applySettingsToUI();
        
        // Load priorities on startup
        await loadTaskPriorities();
      } catch (e) {
        console.error('Failed to load settings:', e);
        currentConfig = getDefaultConfig();
        applySettingsToUI();
        
        // Still try to load priorities even if settings fail
        try {
          await loadTaskPriorities();
        } catch (priorityError) {
          console.error('Failed to load priorities:', priorityError);
        }
      }
    }

    // Populate tag dropdowns with available tags
    async function populateTagDropdown() {
      try {
        availableTags = await PluginAPI.getAllTags();
        
        // Populate "Do Not Reschedule" dropdown
        const doNotRescheduleSelect = document.getElementById('doNotRescheduleTag');
        
        // Clear existing options except the first one (None)
        while (doNotRescheduleSelect.options.length > 1) {
          doNotRescheduleSelect.remove(1);
        }
        
        // Add tags as options
        for (const tag of availableTags) {
          const option = document.createElement('option');
          option.value = tag.id;
          option.textContent = tag.title;
          doNotRescheduleSelect.appendChild(option);
        }
        
        // Re-apply the selected value if we have one
        if (currentConfig.doNotRescheduleTagId) {
          doNotRescheduleSelect.value = currentConfig.doNotRescheduleTagId;
        }
        
        // Also populate the tag priority dropdown
        updateTagPriorityDropdown();
      } catch (e) {
        console.error('Failed to load tags:', e);
      }
    }

    // Update the tag priority dropdown with available tags (excluding already added ones)
    function updateTagPriorityDropdown() {
      const select = document.getElementById('newTagName');
      const configuredTags = Object.keys(currentConfig.tagPriorities || {});
      
      // Clear existing options
      select.innerHTML = '<option value="">Select a tag...</option>';
      
      // Add available tags that aren't already configured
      for (const tag of availableTags) {
        if (!configuredTags.includes(tag.title)) {
          const option = document.createElement('option');
          option.value = tag.title;
          option.textContent = tag.title;
          select.appendChild(option);
        }
      }
    }

    // Populate project dropdown with available projects
    async function populateProjectDropdown() {
      try {
        availableProjects = await PluginAPI.getAllProjects();
        updateProjectPriorityDropdown();
      } catch (e) {
        console.error('Failed to load projects:', e);
      }
    }

    // Update the project priority dropdown with available projects (excluding already added ones)
    function updateProjectPriorityDropdown() {
      const select = document.getElementById('newProjectName');
      const configuredProjects = Object.keys(currentConfig.projectPriorities || {});
      
      // Clear existing options
      select.innerHTML = '<option value="">Select a project...</option>';
      
      // Add available projects that aren't already configured
      for (const project of availableProjects) {
        if (!configuredProjects.includes(project.title)) {
          const option = document.createElement('option');
          option.value = project.title;
          option.textContent = project.title;
          select.appendChild(option);
        }
      }
    }

    // Get default config
    function getDefaultConfig() {
      return {
        blockSizeMinutes: 120,
        tagPriorities: {},
        projectPriorities: {},
        durationFormula: 'linear',
        durationWeight: 1.0,
        oldnessFormula: 'linear',
        oldnessWeight: 1.0,
        maxDaysAhead: 30,
        autoRunOnStart: false,
        splitSuffix: true,
        workdayStartHour: 9,
        workdayHours: 8,
        skipDays: [0, 6], // Sunday and Saturday
        doNotRescheduleTagId: null,
      };
    }

    // Apply settings to UI
    function applySettingsToUI() {
      document.getElementById('blockSize').value = currentConfig.blockSizeMinutes || 120;
      document.getElementById('maxDays').value = currentConfig.maxDaysAhead || 30;
      document.getElementById('autoRun').checked = currentConfig.autoRunOnStart || false;
      document.getElementById('splitSuffix').checked = currentConfig.splitSuffix !== false;
      
      document.getElementById('durationFormula').value = currentConfig.durationFormula || 'linear';
      document.getElementById('durationWeight').value = currentConfig.durationWeight || 1.0;
      document.getElementById('oldnessFormula').value = currentConfig.oldnessFormula || 'linear';
      document.getElementById('oldnessWeight').value = currentConfig.oldnessWeight || 1.0;

      document.getElementById('workdayStartHour').value = currentConfig.workdayStartHour ?? 9;
      document.getElementById('workdayHours').value = currentConfig.workdayHours ?? 8;

      // Apply skip days
      const skipDays = currentConfig.skipDays || [0, 6];
      for (let i = 0; i <= 6; i++) {
        document.getElementById(`skipDay${i}`).checked = skipDays.includes(i);
      }

      // Apply do not reschedule tag (dropdown populated separately)
      const doNotRescheduleSelect = document.getElementById('doNotRescheduleTag');
      if (doNotRescheduleSelect && currentConfig.doNotRescheduleTagId) {
        doNotRescheduleSelect.value = currentConfig.doNotRescheduleTagId;
      }

      updateTagTable();
      updateProjectTable();
      updateFormulaPreview();
    }

    // Collect settings from UI
    function collectSettingsFromUI() {
      // Collect skip days
      const skipDays = [];
      for (let i = 0; i <= 6; i++) {
        if (document.getElementById(`skipDay${i}`).checked) {
          skipDays.push(i);
        }
      }

      // Get do not reschedule tag
      const doNotRescheduleTagId = document.getElementById('doNotRescheduleTag').value || null;

      return {
        blockSizeMinutes: parseInt(document.getElementById('blockSize').value) || 120,
        maxDaysAhead: parseInt(document.getElementById('maxDays').value) || 30,
        autoRunOnStart: document.getElementById('autoRun').checked,
        splitSuffix: document.getElementById('splitSuffix').checked,
        durationFormula: document.getElementById('durationFormula').value,
        durationWeight: parseFloat(document.getElementById('durationWeight').value) || 1.0,
        oldnessFormula: document.getElementById('oldnessFormula').value,
        oldnessWeight: parseFloat(document.getElementById('oldnessWeight').value) || 1.0,
        workdayStartHour: parseInt(document.getElementById('workdayStartHour').value) || 9,
        workdayHours: parseInt(document.getElementById('workdayHours').value) || 8,
        skipDays: skipDays,
        tagPriorities: currentConfig.tagPriorities || {},
        projectPriorities: currentConfig.projectPriorities || {},
        doNotRescheduleTagId: doNotRescheduleTagId,
      };
    }

    // Save settings
    async function saveSettings() {
      try {
        currentConfig = collectSettingsFromUI();
        await PluginAPI.persistDataSynced(JSON.stringify(currentConfig));
        showStatus('Settings saved successfully!', 'success');
      } catch (e) {
        console.error('Failed to save settings:', e);
        showStatus('Failed to save settings: ' + e.message, 'error');
      }
    }

    // Reset to defaults
    function resetToDefaults() {
      if (confirm('Reset all settings to defaults?')) {
        currentConfig = getDefaultConfig();
        applySettingsToUI();
        showStatus('Settings reset to defaults', 'info');
      }
    }

    // Tag priority management
    function updateTagTable() {
      const tbody = document.getElementById('tagTableBody');
      tbody.innerHTML = '';
      
      const tagPriorities = currentConfig.tagPriorities || {};
      
      for (const [tagName, priority] of Object.entries(tagPriorities)) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><span class="tag-badge">${escapeHtml(tagName)}</span></td>
          <td>
            <input type="number" value="${priority}" 
                   onchange="updateTagPriority('${escapeHtml(tagName)}', this.value)">
          </td>
          <td>
            <button class="btn btn-small" onclick="removeTagPriority('${escapeHtml(tagName)}')">
              Remove
            </button>
          </td>
        `;
        tbody.appendChild(row);
      }

      if (Object.keys(tagPriorities).length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No tag priorities configured</td></tr>';
      }
    }

    function addTagPriority() {
      const nameSelect = document.getElementById('newTagName');
      const priorityInput = document.getElementById('newTagPriority');
      
      const name = nameSelect.value;
      const priority = parseFloat(priorityInput.value) || 0;
      
      if (!name) {
        showStatus('Please select a tag', 'error');
        return;
      }

      if (!currentConfig.tagPriorities) {
        currentConfig.tagPriorities = {};
      }
      
      currentConfig.tagPriorities[name] = priority;
      updateTagTable();
      updateTagPriorityDropdown();
      
      priorityInput.value = '10';
    }

    function updateTagPriority(name, value) {
      currentConfig.tagPriorities[name] = parseFloat(value) || 0;
    }

    function removeTagPriority(name) {
      delete currentConfig.tagPriorities[name];
      updateTagTable();
      updateTagPriorityDropdown();
    }

    // Project priority management
    function updateProjectTable() {
      const tbody = document.getElementById('projectTableBody');
      tbody.innerHTML = '';
      
      const projectPriorities = currentConfig.projectPriorities || {};
      
      for (const [projectName, priority] of Object.entries(projectPriorities)) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><span class="tag-badge">${escapeHtml(projectName)}</span></td>
          <td>
            <input type="number" value="${priority}" 
                   onchange="updateProjectPriority('${escapeHtml(projectName)}', this.value)">
          </td>
          <td>
            <button class="btn btn-small" onclick="removeProjectPriority('${escapeHtml(projectName)}')">
              Remove
            </button>
          </td>
        `;
        tbody.appendChild(row);
      }

      if (Object.keys(projectPriorities).length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No project priorities configured</td></tr>';
      }
    }

    function addProjectPriority() {
      const nameSelect = document.getElementById('newProjectName');
      const priorityInput = document.getElementById('newProjectPriority');
      
      const name = nameSelect.value;
      const priority = parseFloat(priorityInput.value) || 0;
      
      if (!name) {
        showStatus('Please select a project', 'error');
        return;
      }

      if (!currentConfig.projectPriorities) {
        currentConfig.projectPriorities = {};
      }
      
      currentConfig.projectPriorities[name] = priority;
      updateProjectTable();
      updateProjectPriorityDropdown();
      
      priorityInput.value = '10';
    }

    function updateProjectPriority(name, value) {
      currentConfig.projectPriorities[name] = parseFloat(value) || 0;
    }

    function removeProjectPriority(name) {
      delete currentConfig.projectPriorities[name];
      updateProjectTable();
      updateProjectPriorityDropdown();
    }



    // Formula preview update
    function updateFormulaPreview() {
      const durationFormula = document.getElementById('durationFormula').value;
      const durationWeight = document.getElementById('durationWeight').value;
      const oldnessFormula = document.getElementById('oldnessFormula').value;
      const oldnessWeight = document.getElementById('oldnessWeight').value;

      const durationFns = {
        none: 'disabled',
        linear: 'hours',
        inverse: '1/(hours+1)',
        log: 'log(hours+1)'
      };

      const oldnessFns = {
        none: 'disabled',
        linear: 'days',
        log: 'log(days+1)',
        exponential: '1.1^days'
      };

      document.getElementById('durationPreview').textContent = 
        `Duration Priority = ${durationFns[durationFormula]} * ${durationWeight}`;
      document.getElementById('oldnessPreview').textContent = 
        `Oldness Priority = ${oldnessFns[oldnessFormula]} * ${oldnessWeight}`;
    }

    // Add event listeners for formula preview
    ['durationFormula', 'durationWeight', 'oldnessFormula', 'oldnessWeight'].forEach(id => {
      document.getElementById(id).addEventListener('change', updateFormulaPreview);
    });

    // Schedule preview
    async function previewSchedule() {
      const container = document.getElementById('schedulePreview');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Generating schedule preview...</div>';

      try {
        // Save current settings first
        await saveSettings();

        // Try to use the full preview from plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(true); // dry run
          const schedule = result.schedule || [];

          if (schedule.length === 0) {
            container.innerHTML = '<p style="opacity: 0.7;">No tasks to schedule. Make sure tasks have time estimates.</p>';
            return;
          }

          // Calculate initial priorities for comparison
          const priorityComparison = await calculatePriorityComparison(schedule);

          // Group by date for better display
          const byDate = new Map();
          for (const item of schedule) {
            const dateStr = item.startTime.toLocaleDateString();
            if (!byDate.has(dateStr)) {
              byDate.set(dateStr, []);
            }
            byDate.get(dateStr).push(item);
          }

          let html = '';
          
          // Show warning if schedule order differs significantly from priority order
          if (priorityComparison.warnings.length > 0) {
            html += `
              <div class="tip-box" style="margin-bottom: 16px; background: rgba(255, 152, 0, 0.1); border-left-color: #ff9800;">
                <strong>Deadline Priority Notice</strong>
                <p style="margin-top: 8px;">Some tasks are scheduled earlier than their base priority would suggest because they have approaching deadlines:</p>
                <ul style="margin: 8px 0 0 16px; padding: 0; font-size: 0.9em;">
                  ${priorityComparison.warnings.map(w => `<li><strong>${escapeHtml(w.title)}</strong>: deadline ${w.deadline ? w.deadline.toLocaleDateString() : 'unknown'}</li>`).join('')}
                </ul>
              </div>
            `;
          }
          
          html += `<p style="margin-bottom: 12px; font-weight: 500;">${schedule.length} blocks scheduled across ${byDate.size} days:</p>`;
          
          for (const [date, items] of byDate) {
            html += `<div style="margin-top: 12px; margin-bottom: 8px; font-weight: 600; opacity: 0.8;">${date}</div>`;
            for (const item of items) {
              const startTime = item.startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const endTime = item.endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const hours = (item.split.estimatedHours).toFixed(1);
              
              // Check if this task has a warning
              const warning = priorityComparison.warnings.find(w => w.taskId === item.split.originalTaskId);
              const warningStyle = warning ? 'border-left: 3px solid #ff9800; padding-left: 8px;' : '';
              
              html += `
                <div class="schedule-item" style="${warningStyle}">
                  <div class="schedule-title">
                    <span style="opacity: 0.6; font-size: 0.9em;">${startTime}-${endTime}</span>
                    ${escapeHtml(item.split.title)}
                  </div>
                  <div class="schedule-urgency">${hours}h</div>
                </div>
              `;
            }
          }

          container.innerHTML = html;
        } else {
          // Fallback: just show eligible tasks
          const tasks = await PluginAPI.getTasks();
          const eligibleTasks = tasks.filter(t => !t.isDone && t.timeEstimate && t.timeEstimate > 0);

          if (eligibleTasks.length === 0) {
            container.innerHTML = '<p style="opacity: 0.7;">No tasks with time estimates found</p>';
            return;
          }

          container.innerHTML = `
            <p style="margin-bottom: 12px;">Found ${eligibleTasks.length} tasks with time estimates:</p>
            ${eligibleTasks.slice(0, 10).map(task => `
              <div class="schedule-item">
                <div class="schedule-title">${escapeHtml(task.title)}</div>
                <div class="schedule-urgency">${Math.round((task.timeEstimate || 0) / 3600000)}h</div>
              </div>
            `).join('')}
            ${eligibleTasks.length > 10 ? `<p style="opacity: 0.7;">...and ${eligibleTasks.length - 10} more tasks</p>` : ''}
            <p style="margin-top: 12px; opacity: 0.7; font-size: 0.9em;">Note: Full preview requires plugin.js to be loaded.</p>
          `;
        }
      } catch (e) {
        console.error('Preview failed:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Run autoplan
    async function runAutoplan() {
      try {
        await saveSettings();
        
        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(false);
          showStatus(`AutoPlan complete: ${result.schedule?.length || 0} blocks scheduled`, 'success');
        } else {
          // Fallback: Show instructions
          showStatus('Please use the AutoPlan header button or Ctrl+Shift+A to run the scheduler', 'info');
        }
      } catch (e) {
        console.error('AutoPlan failed:', e);
        showStatus('AutoPlan failed: ' + e.message, 'error');
      }
    }

    // Clear planning from all eligible tasks
    async function handleClearPlanning() {
      if (!confirm('Are you sure you want to clear all planning?\n\nThis will:\n1. Merge all split tasks back together\n2. Remove scheduled times from tasks with time estimates\n\n(Tasks with "Do Not Reschedule" tag are not affected)')) {
        return;
      }

      try {
        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.clearPlanning();
          let message = '';
          if (result.merged > 0 && result.cleared > 0) {
            message = `Merged ${result.merged} split groups, cleared planning from ${result.cleared} tasks`;
          } else if (result.merged > 0) {
            message = `Merged ${result.merged} split groups`;
          } else if (result.cleared > 0) {
            message = `Cleared planning from ${result.cleared} tasks`;
          } else {
            message = 'No tasks to clear';
          }
          showStatus(message, 'success');
        } else {
          // Fallback: Show instructions
          showStatus('AutoPlanAPI not available. Make sure the plugin is properly loaded.', 'error');
        }
      } catch (e) {
        console.error('Clear planning failed:', e);
        showStatus('Clear planning failed: ' + e.message, 'error');
      }
    }

    // Load and display split groups
    async function loadSplitGroups() {
      const container = document.getElementById('splitGroups');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading split groups...</div>';

      try {
        // Get all tasks and find split groups
        const tasks = await PluginAPI.getTasks();
        const groups = findSplitGroups(tasks);

        if (groups.length === 0) {
          container.innerHTML = '<p style="opacity: 0.7;">No split task groups found</p>';
          return;
        }

        container.innerHTML = groups.map(group => {
          const incompleteSplits = group.splits.filter(s => !s.task.isDone);
          const completedSplits = group.splits.filter(s => s.task.isDone);
          const totalRemaining = incompleteSplits.reduce((sum, s) => sum + (s.task.timeEstimate || 0), 0);
          
          return `
            <div class="section" style="margin-bottom: 12px;">
              <div class="section-title">${escapeHtml(group.originalTitle)}</div>
              <div style="display: flex; gap: 16px; margin-bottom: 12px;">
                <span style="opacity: 0.7;">
                  ${incompleteSplits.length} incomplete / ${completedSplits.length} completed
                </span>
                <span style="font-weight: 500;">
                  ${Math.round(totalRemaining / 3600000)}h remaining
                </span>
              </div>
              <div style="margin-bottom: 12px;">
                ${group.splits.map(s => `
                  <div class="schedule-item" style="opacity: ${s.task.isDone ? '0.5' : '1'};">
                    <div class="schedule-title">
                      ${s.task.isDone ? '&#x2713; ' : ''}${escapeHtml(s.task.title)}
                    </div>
                    <div class="schedule-urgency">
                      ${Math.round((s.task.timeEstimate || 0) / 3600000)}h
                    </div>
                  </div>
                `).join('')}
              </div>
              ${incompleteSplits.length > 1 ? `
                <button class="btn btn-small" onclick="mergeSplitGroup('${group.splits[0].task.id}')">
                  Merge ${incompleteSplits.length} Incomplete Splits
                </button>
              ` : `
                <span style="opacity: 0.7; font-size: 0.85em;">
                  ${incompleteSplits.length === 1 ? 'Only 1 incomplete split remaining' : 'All splits completed'}
                </span>
              `}
            </div>
          `;
        }).join('');
      } catch (e) {
        console.error('Failed to load split groups:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Find split groups from tasks
    function findSplitGroups(tasks) {
      const groups = new Map();

      for (const task of tasks) {
        const splitInfo = parseSplitInfo(task);
        if (splitInfo) {
          if (!groups.has(splitInfo.originalTaskId)) {
            groups.set(splitInfo.originalTaskId, {
              originalTaskId: splitInfo.originalTaskId,
              originalTitle: splitInfo.originalTitle,
              splits: [],
            });
          }
          groups.get(splitInfo.originalTaskId).splits.push({
            task,
            splitInfo,
          });
        }
      }

      // Sort splits within each group
      for (const group of groups.values()) {
        group.splits.sort((a, b) => a.splitInfo.splitIndex - b.splitInfo.splitIndex);
      }

      return Array.from(groups.values());
    }

    // Parse split info from task notes
    function parseSplitInfo(task) {
      if (!task.notes) return null;
      
      // Look for the AutoPlan split marker with [AutoPlan] prefix
      // This prevents false positives from user notes that happen to match the pattern
      // Handle potential special characters in title
      const splitMatch = task.notes.match(/\[AutoPlan\] Split (\d+)\/(\d+) of "((?:[^"\\]|\\.)*)"/);
      const idMatch = task.notes.match(/\[AutoPlan\] Original Task ID: ([^\n\s]+)/);
      
      if (splitMatch && idMatch) {
        return {
          splitIndex: parseInt(splitMatch[1]) - 1,
          totalSplits: parseInt(splitMatch[2]),
          originalTitle: splitMatch[3].replace(/\\"/g, '"'), // Unescape quotes
          originalTaskId: idMatch[1].trim(),
        };
      }
      return null;
    }

    // Merge a split group
    async function mergeSplitGroup(taskId) {
      if (!confirm('Merge all incomplete splits of this task into one?')) {
        return;
      }

      try {
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.mergeSplits(taskId);
          if (result) {
            showStatus(`Merged ${result.mergedCount} splits successfully`, 'success');
            loadSplitGroups(); // Refresh the list
          }
        } else {
          // Manual merge fallback
          const tasks = await PluginAPI.getTasks();
          const task = tasks.find(t => t.id === taskId);
          
          if (!task) {
            showStatus('Task not found', 'error');
            return;
          }

          const splitInfo = parseSplitInfo(task);
          if (!splitInfo) {
            showStatus('Not a split task', 'error');
            return;
          }

          // Find related splits
          const relatedSplits = tasks.filter(t => {
            const info = parseSplitInfo(t);
            return info && info.originalTaskId === splitInfo.originalTaskId && !t.isDone;
          });

          if (relatedSplits.length <= 1) {
            showStatus('Nothing to merge', 'info');
            return;
          }

          // Calculate totals
          let totalEstimate = 0;
          let totalSpent = 0;
          for (const split of relatedSplits) {
            totalEstimate += split.timeEstimate || 0;
            totalSpent += split.timeSpent || 0;
          }

          // Use first split as merged task
          relatedSplits.sort((a, b) => {
            const infoA = parseSplitInfo(a);
            const infoB = parseSplitInfo(b);
            return (infoA?.splitIndex || 0) - (infoB?.splitIndex || 0);
          });

          const mergedTask = relatedSplits[0];
          const toDelete = relatedSplits.slice(1);

          // Update merged task
          await PluginAPI.updateTask(mergedTask.id, {
            title: splitInfo.originalTitle,
            timeEstimate: totalEstimate,
            timeSpent: totalSpent,
            notes: `[AutoPlan] Merged from ${relatedSplits.length} split tasks.`,
          });

          // Delete the other splits
          for (const t of toDelete) {
            try {
              await PluginAPI.deleteTask(t.id);
            } catch (e) {
              console.warn('Could not delete task:', e);
              // Fallback: mark as done
              await PluginAPI.updateTask(t.id, {
                isDone: true,
                notes: `${t.notes || ''}\n\n[AutoPlan] Merged into task: ${mergedTask.id}`,
              });
            }
          }

          showStatus(`Merged ${relatedSplits.length} splits`, 'success');
          loadSplitGroups();
        }
      } catch (e) {
        console.error('Merge failed:', e);
        showStatus('Merge failed: ' + e.message, 'error');
      }
    }

    // Utility: escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load and display task priorities
    async function loadTaskPriorities() {
      const container = document.getElementById('prioritiesList');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading task priorities...</div>';

      try {
        // Get current config for priority calculation
        const configData = await PluginAPI.loadSyncedData();
        const config = configData ? JSON.parse(configData) : getDefaultConfig();
        
        // Get all tasks, tags, and projects
        const tasks = await PluginAPI.getTasks();
        const allTags = await PluginAPI.getAllTags();
        const allProjects = await PluginAPI.getAllProjects();
        
        // Find parent task IDs (tasks that have subtasks)
        const parentIds = new Set();
        for (const task of tasks) {
          if (task.parentId) {
            parentIds.add(task.parentId);
          }
        }
        
        // Build a map of task ID to task for quick parent lookup
        const taskMap = new Map();
        for (const task of tasks) {
          taskMap.set(task.id, task);
        }
        
        // Filter to eligible tasks:
        // - not done
        // - has time estimate
        // - is NOT a parent task (exclude tasks that have subtasks)
        const eligibleTasks = tasks.filter(t => 
          !t.isDone && 
          t.timeEstimate && 
          t.timeEstimate > 0 &&
          !parentIds.has(t.id)
        );

        if (eligibleTasks.length === 0) {
          container.innerHTML = '<p style="opacity: 0.7;">No eligible tasks found. Tasks must have time estimates to be scheduled.</p>';
          return;
        }

        // Calculate priority for each task
        const now = new Date();
        const tasksWithPriority = eligibleTasks.map(task => {
          const urgency = calculateTaskUrgency(task, config, allTags, allProjects, tasks, now);
          return {
            task,
            urgency: urgency.total,
            components: urgency.components
          };
        });

        // Sort by priority (highest first)
        tasksWithPriority.sort((a, b) => b.urgency - a.urgency);

        // Build HTML
        let html = `<p style="margin-bottom: 12px; font-weight: 500;">${tasksWithPriority.length} tasks sorted by priority:</p>`;
        
        for (const item of tasksWithPriority) {
          const { task, urgency, components } = item;
          const hours = Math.round((task.timeEstimate || 0) / 3600000 * 10) / 10;
          
          // Build display title with parent prefix for subtasks
          let displayTitle = task.title;
          if (task.parentId) {
            const parent = taskMap.get(task.parentId);
            if (parent) {
              displayTitle = `${parent.title} > ${task.title}`;
            }
          }
          
          // Build explanation parts (only show non-zero components)
          const explanationParts = [];
          if (components.tag !== 0) explanationParts.push(`tag: ${formatNumber(components.tag)}`);
          if (components.project !== 0) explanationParts.push(`project: ${formatNumber(components.project)}`);
          if (components.duration !== 0) explanationParts.push(`duration: ${formatNumber(components.duration)}`);
          if (components.oldness !== 0) explanationParts.push(`oldness: ${formatNumber(components.oldness)}`);
          if (components.deadline !== 0) explanationParts.push(`deadline: ${formatNumber(components.deadline)}`);
          
          const explanation = explanationParts.length > 0 
            ? explanationParts.join(' + ') 
            : 'no priority factors applied';
          
          html += `
            <div class="priority-item">
              <div class="priority-header">
                <div class="priority-title">${escapeHtml(displayTitle)}</div>
                <div class="priority-score">${formatNumber(urgency)}</div>
              </div>
              <div class="priority-explanation">${hours}h est. | ${explanation}</div>
            </div>
          `;
        }

        container.innerHTML = html;
      } catch (e) {
        console.error('Failed to load priorities:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Format number for display (1 decimal place, remove trailing zeros)
    function formatNumber(num) {
      if (num === 0) return '0';
      const rounded = Math.round(num * 10) / 10;
      return rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(1);
    }

    // Compare initial priority order with scheduled order to detect discrepancies
    async function calculatePriorityComparison(schedule) {
      const warnings = [];
      
      try {
        // Get current config and data
        const configData = await PluginAPI.loadSyncedData();
        const config = configData ? JSON.parse(configData) : getDefaultConfig();
        const tasks = await PluginAPI.getTasks();
        const allTags = await PluginAPI.getAllTags();
        const allProjects = await PluginAPI.getAllProjects();
        
        // Find parent task IDs (tasks that have subtasks)
        const parentIds = new Set();
        for (const task of tasks) {
          if (task.parentId) {
            parentIds.add(task.parentId);
          }
        }
        
        // Build task map for quick lookup
        const taskMap = new Map();
        for (const task of tasks) {
          taskMap.set(task.id, task);
        }
        
        // Get eligible tasks (same filter as Priorities tab)
        const eligibleTasks = tasks.filter(t => 
          !t.isDone && 
          t.timeEstimate && 
          t.timeEstimate > 0 &&
          !parentIds.has(t.id)
        );
        
        // Calculate initial priority for each task (excluding deadline component)
        const now = new Date();
        const tasksWithPriority = eligibleTasks.map(task => {
          const urgency = calculateTaskUrgency(task, config, allTags, allProjects, tasks, now);
          // Calculate priority WITHOUT deadline to see base priority
          const basePriority = urgency.total - (urgency.components.deadline || 0);
          const deadline = getTaskDueDate(task);
          return {
            taskId: task.id,
            title: task.title,
            urgency: urgency.total,
            basePriority,
            deadlinePriority: urgency.components.deadline || 0,
            deadline
          };
        });
        
        // Sort by BASE priority (without deadline) to get base ranking
        const tasksForBaseRanking = [...tasksWithPriority];
        tasksForBaseRanking.sort((a, b) => b.basePriority - a.basePriority);
        
        // Create base priority rank map (1-based)
        const basePriorityRankMap = new Map();
        tasksForBaseRanking.forEach((item, index) => {
          basePriorityRankMap.set(item.taskId, index + 1);
        });
        
        // Get first occurrence of each original task in the schedule (schedule order)
        const scheduleOrder = [];
        const seenTaskIds = new Set();
        for (const item of schedule) {
          const taskId = item.split.originalTaskId;
          if (!seenTaskIds.has(taskId)) {
            seenTaskIds.add(taskId);
            scheduleOrder.push({
              taskId,
              title: item.split.originalTask?.title || item.split.title
            });
          }
        }
        
        // Create schedule rank map (1-based)
        const scheduleRankMap = new Map();
        scheduleOrder.forEach((item, index) => {
          scheduleRankMap.set(item.taskId, index + 1);
        });
        
        // Find tasks that are scheduled earlier than their base priority suggests
        // Only include tasks that have a deadline (since that's what causes the boost)
        for (const item of scheduleOrder) {
          const basePriorityRank = basePriorityRankMap.get(item.taskId);
          const scheduleRank = scheduleRankMap.get(item.taskId);
          const taskInfo = tasksWithPriority.find(t => t.taskId === item.taskId);
          
          if (basePriorityRank && scheduleRank && taskInfo) {
            // Task is scheduled earlier if scheduleRank < basePriorityRank
            // Only warn if the task has a deadline AND is scheduled significantly earlier
            const rankDifference = basePriorityRank - scheduleRank;
            if (rankDifference >= 2 && taskInfo.deadline) {
              warnings.push({
                taskId: item.taskId,
                title: item.title,
                priorityRank: basePriorityRank,
                scheduleRank,
                difference: rankDifference,
                deadline: taskInfo.deadline
              });
            }
          }
        }
        
        // Sort warnings by how much earlier they were scheduled
        warnings.sort((a, b) => b.difference - a.difference);
        
        // Limit to top 5 warnings to avoid clutter
        return { warnings: warnings.slice(0, 5) };
        
      } catch (e) {
        console.error('Failed to calculate priority comparison:', e);
        return { warnings: [] };
      }
    }

    // Calculate task urgency (mirrors PriorityCalculator.calculateUrgency from core.js)
    function calculateTaskUrgency(task, config, allTags, allProjects, allTasks, now) {
      const tagPriority = calculateTagPriority(task, config.tagPriorities || {}, allTags, allTasks);
      const projectPriority = calculateProjectPriority(task, config.projectPriorities || {}, allProjects);
      const durationPriority = calculateDurationPriority(task, config.durationFormula || 'none', config.durationWeight ?? 1.0);
      const oldnessPriority = calculateOldnessPriority(task, config.oldnessFormula || 'none', config.oldnessWeight ?? 1.0, now);
      const deadlinePriority = calculateDeadlinePriority(task, config.deadlineFormula || 'none', config.deadlineWeight ?? 12.0, now);

      // Apply urgencyWeight to non-deadline factors
      const urgencyWeight = config.urgencyWeight ?? 1.0;
      const nonDeadlineUrgency = (tagPriority + projectPriority + durationPriority + oldnessPriority) * urgencyWeight;

      return {
        total: nonDeadlineUrgency + deadlinePriority,
        components: {
          tag: tagPriority * urgencyWeight,
          project: projectPriority * urgencyWeight,
          duration: durationPriority * urgencyWeight,
          oldness: oldnessPriority * urgencyWeight,
          deadline: deadlinePriority
        }
      };
    }

    // Get effective tag IDs including inherited from parent
    function getEffectiveTagIds(task, allTasks) {
      const tagIds = new Set(task.tagIds || []);
      if (task.parentId && allTasks) {
        const parent = allTasks.find(t => t.id === task.parentId);
        if (parent) {
          const parentTags = getEffectiveTagIds(parent, allTasks);
          for (const tagId of parentTags) {
            tagIds.add(tagId);
          }
        }
      }
      return Array.from(tagIds);
    }

    // Calculate tag-based priority boost
    function calculateTagPriority(task, tagPriorities, allTags, allTasks) {
      const effectiveTagIds = getEffectiveTagIds(task, allTasks);
      if (effectiveTagIds.length === 0) return 0;
      if (!tagPriorities || typeof tagPriorities !== 'object') return 0;
      
      let boost = 0;
      for (const tagId of effectiveTagIds) {
        const tag = allTags.find(t => t.id === tagId);
        if (tag && tagPriorities[tag.title] !== undefined) {
          boost += Number(tagPriorities[tag.title]) || 0;
        }
      }
      return boost;
    }

    // Calculate project-based priority boost
    function calculateProjectPriority(task, projectPriorities, allProjects) {
      if (!task.projectId) return 0;
      if (!projectPriorities || typeof projectPriorities !== 'object') return 0;
      
      const project = allProjects.find(p => p.id === task.projectId);
      if (project && projectPriorities[project.title] !== undefined) {
        return Number(projectPriorities[project.title]) || 0;
      }
      return 0;
    }

    // Get remaining hours for task
    function getRemainingHours(task) {
      const estimated = (task.timeEstimate || 0) / (1000 * 60 * 60);
      const spent = (task.timeSpent || 0) / (1000 * 60 * 60);
      return Math.max(0, estimated - spent);
    }

    // Calculate duration-based priority factor
    function calculateDurationPriority(task, formula, weight) {
      const hours = getRemainingHours(task);
      if (hours <= 0 || formula === 'none') return 0;
      if (weight <= 0) return 0;

      let factor;
      switch (formula) {
        case 'inverse':
          factor = 1 / (hours + 1);
          break;
        case 'log':
          factor = Math.log(hours + 1);
          break;
        case 'linear':
        default:
          factor = hours;
          break;
      }
      return factor * weight;
    }

    // Get task age in days
    function getTaskAgeInDays(task, now) {
      if (!task.created) return 0;
      const created = new Date(task.created);
      return Math.abs(now - created) / (1000 * 60 * 60 * 24);
    }

    // Calculate oldness-based priority factor
    function calculateOldnessPriority(task, formula, weight, now) {
      const days = getTaskAgeInDays(task, now);
      if (days <= 0 || formula === 'none') return 0;
      if (weight <= 0) return 0;

      let factor;
      switch (formula) {
        case 'exponential':
          const cappedDays = Math.min(days, 100);
          factor = Math.pow(1.1, cappedDays);
          break;
        case 'log':
          factor = Math.log(days + 1);
          break;
        case 'linear':
        default:
          factor = days;
          break;
      }
      return factor * weight;
    }

    // Parse deadline from task notes
    function parseDeadlineFromNotes(notes) {
      if (!notes || typeof notes !== 'string') return null;
      
      const patterns = [
        /(?:due|deadline)\s*:\s*(\d{4}-\d{2}-\d{2})/i,
        /(?:due|deadline)\s*:\s*([A-Za-z]{3,9}\s+\d{1,2},?\s+\d{4})/i,
        /(?:due|deadline)\s*:\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
      ];
      
      for (const pattern of patterns) {
        const match = notes.match(pattern);
        if (match) {
          const dateStr = match[1];
          if (dateStr.includes('/')) {
            const parts = dateStr.split('/');
            if (parts.length === 3) {
              const [first, second, year] = parts.map(p => parseInt(p, 10));
              if (first > 12 && second >= 1 && second <= 12) {
                return new Date(year, second - 1, first);
              }
              if (first >= 1 && first <= 12 && second >= 1 && second <= 31) {
                return new Date(year, first - 1, second);
              }
            }
          } else {
            const parsed = new Date(dateStr);
            if (!isNaN(parsed.getTime())) {
              return parsed;
            }
          }
        }
      }
      return null;
    }

    // Get task due date
    function getTaskDueDate(task) {
      const notesDeadline = parseDeadlineFromNotes(task.notes);
      if (notesDeadline) return notesDeadline;
      if (task.dueDate) return new Date(task.dueDate);
      return null;
    }

    // Calculate deadline-based priority factor
    function calculateDeadlinePriority(task, formula, weight, now) {
      if (formula === 'none') return 0;
      if (weight <= 0) return 0;

      const dueDate = getTaskDueDate(task);
      if (!dueDate) return 0;

      const daysUntilDue = (dueDate - now) / (1000 * 60 * 60 * 24);

      let factor;
      switch (formula) {
        case 'aggressive':
          if (daysUntilDue <= -7) {
            factor = 1.0;
          } else if (daysUntilDue <= 0) {
            factor = 0.9 + (-daysUntilDue / 7) * 0.1;
          } else if (daysUntilDue <= 7) {
            factor = 0.9 - (daysUntilDue / 7) * 0.4;
          } else if (daysUntilDue <= 14) {
            factor = 0.5 - ((daysUntilDue - 7) / 7) * 0.3;
          } else {
            factor = 0.2;
          }
          break;
        case 'linear':
        default:
          if (daysUntilDue <= -7) {
            factor = 1.0;
          } else if (daysUntilDue >= 14) {
            factor = 0.2;
          } else {
            factor = 1.0 - ((daysUntilDue + 7) / 21) * 0.8;
          }
          break;
      }

      return factor * weight;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadSettings();
    });

    // Also try to load immediately in case DOMContentLoaded already fired
    if (document.readyState !== 'loading') {
      loadSettings();
    }
  </script>
</body>
</html>
