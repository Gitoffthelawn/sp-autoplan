<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AutoPlan Settings</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      margin: 0;
      padding: 20px;
      color: var(--text-color);
    }

    h1 {
      font-size: 14px;
      margin: 0 0 4px 0;
    }

    .subtitle {
      font-size: 14px;
      opacity: 0.7;
      margin-bottom: 20px;
    }

    .section {
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--separator-color);
    }

    .section:last-of-type {
      border-bottom: none;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    label {
      display: block;
      font-size: 0.9em;
      opacity: 0.7;
      margin-bottom: 4px;
    }

    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 8px;
      font-size: inherit;
      font-family: inherit;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .checkbox-group label {
      margin-bottom: 0;
      opacity: 1;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .help-text {
      font-size: 0.8em;
      opacity: 0.6;
      margin-top: 4px;
    }

    .section-description {
      font-size: 0.9em;
      opacity: 0.7;
      margin-bottom: 12px;
    }

    /* Intro section */
    .intro-section {
      margin-bottom: 20px;
    }

    .how-it-works {
      margin-bottom: 12px;
    }

    .how-it-works summary {
      cursor: pointer;
      font-weight: 500;
      opacity: 0.8;
      padding: 8px 0;
      user-select: none;
    }

    .how-it-works summary:hover {
      opacity: 1;
    }

    /* When closed, show greyed out text */
    .how-it-works:not([open]) summary {
      color: #888 !important;
      font-weight: normal;
    }

    /* When open, restore normal styling */
    .how-it-works[open] summary {
      font-weight: 500;
    }

    .intro-content {
      padding: 12px;
      background: rgba(128, 128, 128, 0.1);
      border-radius: 4px;
      margin-top: 8px;
    }

    .intro-content ol {
      padding-left: 20px;
      margin: 12px 0;
    }

    .intro-content li {
      margin-bottom: 8px;
    }

    .tip-box {
      padding: 12px;
      background: rgba(124, 77, 255, 0.1);
      border-left: 3px solid var(--c-primary, #7c4dff);
      border-radius: 4px;
      margin-bottom: 16px;
    }

    .tip-box p {
      margin: 8px 0 0 0;
      font-size: 0.9em;
      opacity: 0.85;
    }

    .tip-box strong {
      display: block;
      margin-bottom: 4px;
    }

    /* Tag Priorities Table */
    .tag-table {
      width: 100%;
      border-collapse: collapse;
    }

    .tag-table th,
    .tag-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid var(--separator-color);
    }

    .tag-table th {
      font-weight: 600;
      font-size: 0.8em;
      text-transform: uppercase;
      opacity: 0.7;
    }

    .tag-table input {
      width: 80px;
    }

    .tag-badge {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--separator-color);
      border-radius: 12px;
      font-size: 0.85em;
    }

    .add-tag-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .add-tag-row input {
      flex: 1;
    }

    /* Buttons */
    .btn {
      padding: 8px 16px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      font-size: inherit;
      font-family: inherit;
      cursor: pointer;
      background: transparent;
      color: var(--text-color);
    }

    .btn:hover {
      opacity: 0.8;
    }

    .btn-primary {
      background: var(--c-primary, #7c4dff);
      border: 2px solid var(--c-primary, #7c4dff);
      color: var(--c-primary-contrast, #ffffff);
    }

    .btn-primary:hover {
      opacity: 0.9;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .btn-small {
      padding: 4px 10px;
      font-size: 0.85em;
    }

    .actions {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    /* Schedule Preview */
    .schedule-preview {
      max-height: 500px;
      overflow-y: auto;
    }

    .schedule-day {
      margin-bottom: 16px;
    }

    .schedule-day-header {
      font-weight: 600;
      padding: 8px 0;
      border-bottom: 2px solid var(--c-primary, #7c4dff);
      margin-bottom: 8px;
      position: sticky;
      top: 0;
      background: var(--background-color, #fff);
    }

    .schedule-item {
      display: flex;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--separator-color);
    }

    .schedule-item:last-child {
      border-bottom: none;
    }

    .schedule-time {
      font-size: 0.85em;
      font-weight: 500;
      min-width: 110px;
      color: var(--c-primary, #7c4dff);
    }

    .schedule-title {
      flex: 1;
      margin-right: 16px;
      margin-left: 16px;
    }

    .schedule-urgency {
      font-size: 0.85em;
      padding: 2px 8px;
      border: 1px solid var(--separator-color);
      border-radius: 10px;
      white-space: nowrap;
    }

    .schedule-summary {
      padding: 12px;
      background: rgba(var(--c-primary-rgb, 124, 77, 255), 0.1);
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .schedule-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
    }

    /* Status Messages */
    .status {
      padding: 10px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      margin-bottom: 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
    }

    .status.show {
      display: flex;
    }

    .status-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.7;
      padding: 0 4px;
      margin-left: 12px;
      color: inherit;
    }

    .status-close:hover {
      opacity: 1;
    }

    .status.warning {
      background: rgba(255, 152, 0, 0.1);
      border-color: #ff9800;
    }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: var(--background-color, #fff);
      border-radius: 8px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .modal-title {
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 16px;
    }

    .modal-body {
      margin-bottom: 20px;
      line-height: 1.5;
    }

    .modal-body ul {
      margin: 12px 0;
      padding-left: 20px;
    }

    .modal-body li {
      margin-bottom: 4px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    /* Danger button */
    .btn-danger {
      background: #dc3545;
      border-color: #dc3545;
      color: #fff;
      opacity: 0.7;
    }

    .btn-danger:hover {
      opacity: 1;
      background: #c82333;
      border-color: #bd2130;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 40px;
      opacity: 0.7;
    }

    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid var(--separator-color);
      border-top-color: var(--c-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--separator-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .tab {
      padding: 10px 16px;
      cursor: pointer;
      opacity: 0.6;
      border-bottom: 2px solid transparent;
    }

    .tab:hover {
      opacity: 0.9;
    }

    .tab.active {
      opacity: 1;
      border-bottom-color: var(--c-primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active,
    div.tab-content.active,
    #tab-merge.active,
    #tab-priorities.active,
    #tab-tags-priorities.active,
    #tab-time-maps.active,
    #tab-formulas.active,
    #tab-other-settings.active {
      display: block;
    }

    /* Formula editor */
    .formula-preview {
      padding: 10px;
      border: 1px solid var(--separator-color);
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
      margin-top: 8px;
      opacity: 0.8;
    }

    /* Run AutoPlan Section */
    .run-section {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--separator-color, #e0e0e0);
    }

    .btn-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--c-primary-contrast);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Priority List */
    .priority-item {
      padding: 10px 0;
      border-bottom: 1px solid var(--separator-color);
    }

    .priority-item:last-child {
      border-bottom: none;
    }

    .priority-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .priority-title {
      flex: 1;
      font-weight: 500;
    }

    .priority-score {
      font-size: 0.9em;
      font-weight: 600;
      padding: 4px 10px;
      background: var(--c-primary, #7c4dff);
      color: var(--c-primary-contrast, #ffffff);
      border-radius: 12px;
      white-space: nowrap;
    }

    .priority-explanation {
      font-size: 0.8em;
      opacity: 0.5;
      margin-top: 4px;
      font-family: monospace;
    }

    /* Time Map Styles */
    .time-map-card {
      border: 1px solid var(--separator-color);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .time-map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .time-map-name {
      font-weight: 600;
      font-size: 1em;
    }

    .time-map-actions {
      display: flex;
      gap: 8px;
    }

    .time-map-schedule {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      font-size: 0.75em;
    }

    .time-map-day {
      text-align: center;
      padding: 4px;
      border-radius: 4px;
      background: rgba(128, 128, 128, 0.1);
    }

    .time-map-day.skip {
      opacity: 0.4;
    }

    .time-map-day-name {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .time-map-day-hours {
      opacity: 0.7;
    }

    /* Time Map Day Editor (in modal) */
    .day-editor-row {
      display: grid;
      grid-template-columns: 80px 1fr;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid var(--separator-color);
    }

    .day-editor-row:last-child {
      border-bottom: none;
    }

    .day-editor-name {
      font-weight: 500;
    }

    .day-editor-inputs {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .day-editor-inputs input[type="number"] {
      width: 60px;
    }

    .day-editor-inputs .checkbox-group {
      margin-left: auto;
    }

    /* Compact mode (side panel) styles */
    .compact-only {
      display: none;
    }

    .full-only {
      display: block;
    }

    body.compact-mode .compact-only {
      display: block;
    }

    body.compact-mode .full-only {
      display: none;
    }

    body.compact-mode .tabs,
    body.compact-mode .tab-content {
      display: none !important;
    }

    body.compact-mode .run-section {
      margin-bottom: 0;
    }

    .open-settings-btn {
      width: 100%;
      margin-top: 16px;
      padding: 12px;
      font-size: 1em;
    }
  </style>
</head>
<body>
  <h1>AutoPlan</h1>
  <p class="subtitle">Automatic task scheduling based on priority and urgency</p>

  <div id="status" class="status"></div>

  <!-- Action Buttons Section -->
  <div class="run-section">
    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
      <button class="btn btn-primary" style="flex: 1;" onclick="handleDryRun()">
        üîç Dry Run
      </button>
      <button class="btn btn-primary" style="flex: 1;" id="applyButton" onclick="handleApplySchedule()">
        <span id="applyButtonContent">‚ö° Apply Schedule</span>
      </button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Clear Planning</div>
    
    <button class="btn btn-danger" onclick="showClearPlanningModal()">
      Clear All Planning
    </button>
  </div>

  <!-- Tabs -->
  <div class="tabs">
    <div class="tab active" data-tab="priorities">Task Priorities</div>
    <div class="tab" data-tab="tags-priorities">Tags and Projects Settings</div>
    <div class="tab" data-tab="time-maps">Time Maps</div>
    <div class="tab" data-tab="formulas">Priority formulas</div>
    <div class="tab" data-tab="other-settings">Other settings</div>
    <div class="tab" data-tab="merge">Manage Split Tasks</div>
  </div>

  <!-- Task Priorities Tab (Default/First) -->
  <div id="tab-priorities" class="tab-content active">
    <div class="section">
      <div class="section-title">Task Priorities</div>
      <p class="section-description">
        Tasks sorted by their computed priority score. Higher priority tasks are scheduled first.
      </p>
      
      <button class="btn" onclick="loadTaskPriorities()">
        Refresh Priorities
      </button>

      <div id="prioritiesList" style="margin-top: 16px;">
        <div class="loading"><div class="spinner"></div>Loading task priorities...</div>
      </div>
    </div>
    
    <div class="section" id="schedulePreviewSection" style="display: none;">
      <div class="section-title">Schedule Preview</div>
      <p class="section-description">
        Preview of what tasks would be scheduled and when. Click "Dry Run" to generate this preview.
      </p>
      <div id="schedulePreview">
        <!-- Schedule preview will be populated here -->
      </div>
    </div>
  </div>

  <!-- Setting tags and priorities Tab -->
  <div id="tab-tags-priorities" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How Tags and Project Priorities Work</strong></p>
        <p>When a task has a tag or belongs to a project listed here, that boost value is added to its total priority score. Tasks with higher priority get scheduled earlier.</p>
        <p><strong>Examples:</strong></p>
        <ul>
          <li>Add +20 to "Urgent" tag to schedule urgent tasks sooner</li>
          <li>Add -10 to "Low Priority" to push those tasks later</li>
          <li>Add +15 to "Work" project to prioritize work tasks</li>
        </ul>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Tag Priority Boosts</div>
      <p class="section-description">
        Give certain types of tasks higher or lower priority based on their tags.
      </p>
      
      <table class="tag-table" id="tagTable">
        <thead>
          <tr>
            <th>Tag Name</th>
            <th>Priority Boost</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="tagTableBody">
          <!-- Tags will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newTagName">
          <option value="">Select a tag...</option>
        </select>
        <input type="number" id="newTagPriority" placeholder="Boost" value="10" style="width: 80px;">
        <button class="btn btn-small" onclick="addTagPriority()">Add Tag</button>
      </div>
      <p class="help-text">Select a tag from the dropdown to add a priority boost.</p>
    </div>

    <div class="section">
      <div class="section-title">Project Priority Boosts</div>
      <p class="section-description">
        Give tasks in certain projects higher or lower priority.
      </p>
      
      <table class="tag-table" id="projectTable">
        <thead>
          <tr>
            <th>Project Name</th>
            <th>Priority Boost</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="projectTableBody">
          <!-- Projects will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newProjectName">
          <option value="">Select a project...</option>
        </select>
        <input type="number" id="newProjectPriority" placeholder="Boost" value="10" style="width: 80px;">
        <button class="btn btn-small" onclick="addProjectPriority()">Add Project</button>
      </div>
      <p class="help-text">Select a project from the dropdown to add a priority boost.</p>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Time Maps Tab -->
  <div id="tab-time-maps" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How Time Maps Work</strong></p>
        <p>Time maps define when tasks can be scheduled. Each time map has per-day settings for start/end hours, or can skip days entirely.</p>
        <p><strong>Examples:</strong></p>
        <ul>
          <li><strong>Default:</strong> Work hours Mon-Fri 9am-5pm, weekends off</li>
          <li><strong>Evenings:</strong> Personal tasks scheduled 7pm-10pm on weekdays</li>
          <li><strong>Weekends Only:</strong> Side projects scheduled Sat-Sun 10am-4pm</li>
        </ul>
        <p>You can assign different projects to different time maps, so work tasks and personal tasks don't overlap.</p>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Time Maps</div>
      <p class="section-description">
        Define different scheduling windows. Each time map specifies available hours for each day of the week.
      </p>
      
      <div id="timeMapsContainer">
        <!-- Time maps will be populated here -->
      </div>
      
      <button class="btn" onclick="showAddTimeMapModal()" style="margin-top: 12px;">
        + Add Time Map
      </button>
    </div>

    <div class="section">
      <div class="section-title">Project Time Map Assignments</div>
      <p class="section-description">
        Assign projects to specific time maps. Tasks from unassigned projects use the default time map.
      </p>
      
      <div class="form-group">
        <label for="defaultTimeMapSelect">Default Time Map</label>
        <select id="defaultTimeMapSelect" onchange="updateDefaultTimeMap()">
          <!-- Options populated dynamically -->
        </select>
        <p class="help-text">Used for tasks from projects without a specific assignment.</p>
      </div>
      
      <table class="tag-table" id="projectTimeMapTable">
        <thead>
          <tr>
            <th>Project</th>
            <th>Time Map</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="projectTimeMapTableBody">
          <!-- Project assignments will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newProjectTimeMapProject">
          <option value="">Select a project...</option>
        </select>
        <select id="newProjectTimeMapTimeMap">
          <option value="">Select a time map...</option>
        </select>
        <button class="btn btn-small" onclick="addProjectTimeMapAssignment()">Assign</button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Tag Time Map Assignments</div>
      <p class="section-description">
        Assign tags to specific time maps. Tasks with these tags will be scheduled in the corresponding time map.
        A task can belong to multiple time maps if it has multiple mapped tags.
      </p>
      
      <table class="tag-table" id="tagTimeMapTable">
        <thead>
          <tr>
            <th>Tag</th>
            <th>Time Map</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="tagTimeMapTableBody">
          <!-- Tag assignments will be populated here -->
        </tbody>
      </table>

      <div class="add-tag-row">
        <select id="newTagTimeMapTag">
          <option value="">Select a tag...</option>
        </select>
        <select id="newTagTimeMapTimeMap">
          <option value="">Select a time map...</option>
        </select>
        <button class="btn btn-small" onclick="addTagTimeMapAssignment()">Assign</button>
      </div>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Setting formulas Tab -->
  <div id="tab-formulas" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>Understanding Priority Formulas</strong></p>
        <p>These formulas add bonus priority based on task characteristics. The weight controls how much influence each factor has on the final priority score.</p>
        <p><strong>Duration Priority:</strong> Should shorter or longer tasks be prioritized?</p>
        <p><strong>Oldness Priority:</strong> Should older tasks be prioritized to prevent them from being forgotten?</p>
        <p><strong>Deadline Priority:</strong> Should tasks with approaching deadlines be prioritized? This uses the task's due date.</p>
        <p><strong>Total Formula:</strong> Total Priority = Tag Boosts + Project Boosts + Duration Factor + Oldness Factor + Deadline Factor</p>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Duration Priority Formula</div>
      <p class="section-description">
        Should shorter or longer tasks be prioritized?
      </p>
      
      <div class="row">
        <div class="form-group">
          <label for="durationFormula">Formula Type</label>
          <select id="durationFormula">
            <option value="none">None (duration doesn't affect priority)</option>
            <option value="linear">Linear - longer tasks = higher priority</option>
            <option value="inverse">Inverse - shorter tasks = higher priority</option>
            <option value="log">Logarithmic - moderate effect, diminishing returns</option>
          </select>
        </div>
        <div class="form-group">
          <label for="durationWeight">Weight (0-10)</label>
          <input type="number" id="durationWeight" min="0" max="10" step="0.1" value="1.0">
          <p class="help-text">Higher = stronger effect. Set to 0 to disable.</p>
        </div>
      </div>

      <div class="formula-preview" id="durationPreview">
        Duration Priority = linear(hours) * 1.0
      </div>
    </div>

    <div class="section">
      <div class="section-title">Oldness Priority Formula</div>
      <p class="section-description">
        Should older tasks be prioritized to prevent them from being forgotten?
      </p>
      
      <div class="row">
        <div class="form-group">
          <label for="oldnessFormula">Formula Type</label>
          <select id="oldnessFormula">
            <option value="none">None (age doesn't affect priority)</option>
            <option value="linear">Linear - priority grows steadily with age</option>
            <option value="log">Logarithmic - quick initial boost, then levels off</option>
            <option value="exponential">Exponential - old tasks become very urgent</option>
          </select>
        </div>
        <div class="form-group">
          <label for="oldnessWeight">Weight (0-10)</label>
          <input type="number" id="oldnessWeight" min="0" max="10" step="0.1" value="1.0">
          <p class="help-text">Higher = stronger effect. Set to 0 to disable.</p>
        </div>
      </div>

      <div class="formula-preview" id="oldnessPreview">
        Oldness Priority = linear(days) * 1.0
      </div>
    </div>

    <div class="section">
      <div class="section-title">Deadline Priority Formula</div>
      <p class="section-description">
        Should tasks with approaching deadlines be prioritized? Tasks with due dates will get higher priority as their deadline approaches.
      </p>
      
      <div class="row">
        <div class="form-group">
          <label for="deadlineFormula">Formula Type</label>
          <select id="deadlineFormula">
            <option value="none">None (deadlines don't affect priority)</option>
            <option value="linear">Linear - steady increase as deadline approaches</option>
            <option value="aggressive">Aggressive - sharp increase near deadline</option>
          </select>
        </div>
        <div class="form-group">
          <label for="deadlineWeight">Weight (0-20)</label>
          <input type="number" id="deadlineWeight" min="0" max="20" step="0.5" value="12.0">
          <p class="help-text">Higher = stronger effect. Default is 12.0.</p>
        </div>
      </div>

      <div class="formula-preview" id="deadlinePreview">
        Deadline Priority = linear(days_until_due) * 12.0
      </div>
    </div>

    <div class="section">
      <div class="section-title">Total Priority Formula</div>
      <p class="section-description">The final priority score combines all factors:</p>
      <div class="formula-preview">
        Total Priority = Tag Boosts + Project Boosts + Duration Factor + Oldness Factor + Deadline Factor
      </div>
      <p class="help-text" style="margin-top: 8px;">
        Tasks with higher total priority get scheduled first.
      </p>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Other settings Tab -->
  <div id="tab-other-settings" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How AutoPlan Works</strong></p>
        <p>AutoPlan automatically schedules your tasks by splitting them into time blocks and assigning them to your calendar based on calculated urgency.</p>
        <ol>
          <li><strong>Priority Calculation:</strong> Each task gets a priority score based on tags, projects, duration, and age</li>
          <li><strong>Task Splitting:</strong> Large tasks are split into manageable time blocks (e.g., 2-hour chunks)</li>
          <li><strong>Smart Scheduling:</strong> Blocks are scheduled iteratively - the most urgent task gets the next available slot, then priorities are recalculated</li>
          <li><strong>Calendar Integration:</strong> Scheduled blocks appear in your Super Productivity timeline</li>
        </ol>
        <p><strong>Requirements:</strong> Tasks must have a time estimate to be scheduled. Tasks without estimates are skipped.</p>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Block Settings</div>
      <p class="section-description">Control how tasks are divided into schedulable time blocks.</p>
      
      <div class="row">
        <div class="form-group">
          <label for="blockSize">Preferred Block Size (minutes)</label>
          <input type="number" id="blockSize" min="15" max="480" step="15" value="120">
          <p class="help-text">Target duration for each scheduled block. Example: A 6-hour task becomes 3 x 2-hour blocks.</p>
        </div>
        <div class="form-group">
          <label for="minBlockSize">Minimum Block Size (minutes)</label>
          <input type="number" id="minBlockSize" min="5" max="120" step="5" value="30">
          <p class="help-text">Smallest block allowed. If remaining time in a day is less than this, it's left empty.</p>
        </div>
      </div>

      <div class="row">
        <div class="form-group">
          <label for="maxDays">Planning Horizon (days)</label>
          <input type="number" id="maxDays" min="1" max="365" value="30">
          <p class="help-text">How far ahead to schedule tasks. Tasks won't be scheduled beyond this many days from today.</p>
        </div>
        <div class="form-group">
          <div class="checkbox-group" style="margin-top: 28px;">
            <input type="checkbox" id="autoRun">
            <label for="autoRun">Auto-run on startup</label>
          </div>
          <p class="help-text">Automatically reschedule all tasks when Super Productivity starts.</p>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Task Splitting</div>
      <p class="section-description">Configure how split tasks are named.</p>
      
      <div class="form-group">
        <div class="checkbox-group">
          <input type="checkbox" id="splitSuffix" checked>
          <label for="splitSuffix">Add Roman numeral suffix (&lt;I&gt;, &lt;II&gt;, &lt;III&gt;...)</label>
        </div>
        <p class="help-text">When enabled, split tasks are named "Task Name &lt;I&gt;", "Task Name &lt;II&gt;", etc. When disabled, all splits keep the original task name.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Fixed Tasks (Do Not Reschedule)</div>
      <p class="section-description">Some tasks have fixed times (meetings, appointments) and shouldn't be moved by AutoPlan.</p>
      
      <div class="form-group">
        <label for="doNotRescheduleTag">Do Not Reschedule Tag</label>
        <select id="doNotRescheduleTag">
          <option value="">(None - reschedule all tasks)</option>
          <!-- Tags will be populated dynamically -->
        </select>
        <p class="help-text">Tasks with this tag will keep their existing schedule and won't be rescheduled. Their time is subtracted from available hours on those days, so other tasks schedule around them.</p>
      </div>
      
      <div class="form-group">
        <div class="checkbox-group">
          <input type="checkbox" id="treatIcalAsFixed">
          <label for="treatIcalAsFixed">Treat iCal tasks as fixed</label>
        </div>
        <p class="help-text">When enabled, tasks imported from iCal (calendar events) will be treated as fixed and won't be rescheduled. They will be skipped in the priority list.</p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Work Schedule</div>
      <p class="section-description">Define your available working hours. Tasks will only be scheduled during these times.</p>
      
      <div class="row">
        <div class="form-group">
          <label for="workdayStartHour">Workday Start Hour (0-23)</label>
          <input type="number" id="workdayStartHour" min="0" max="23" value="9">
          <p class="help-text">Hour when your workday begins (24-hour format). Example: 9 = 9:00 AM</p>
        </div>
        <div class="form-group">
          <label for="workdayHours">Workday Length (hours)</label>
          <input type="number" id="workdayHours" min="1" max="24" value="8">
          <p class="help-text">How many hours you work per day. Example: 8 hours starting at 9 AM = work until 5 PM</p>
        </div>
      </div>

      <div class="form-group">
        <label>Days Off</label>
        <p class="help-text" style="margin-bottom: 8px;">Select days when no tasks should be scheduled (weekends, rest days, etc.)</p>
        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay0" checked>
            <span>Sunday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay1">
            <span>Monday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay2">
            <span>Tuesday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay3">
            <span>Wednesday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay4">
            <span>Thursday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay5">
            <span>Friday</span>
          </label>
          <label class="checkbox-group" style="min-width: 100px;">
            <input type="checkbox" id="skipDay6" checked>
            <span>Saturday</span>
          </label>
        </div>
      </div>
    </div>

    <div class="actions">
      <button class="btn" onclick="saveSettings()">Save Settings</button>
      <button class="btn" onclick="resetToDefaults()">Reset to Defaults</button>
    </div>
  </div>

  <!-- Manage Split Tasks Tab -->
  <div id="tab-merge" class="tab-content">
    <details class="how-it-works">
      <summary style="color: #888;">Show Help</summary>
      <div class="intro-content">
        <p><strong>How Merging Works</strong></p>
        <p>When AutoPlan splits a task into multiple blocks, you can merge them back together here.</p>
        <ul>
          <li><strong>Incomplete splits</strong> are combined into one task</li>
          <li><strong>Time estimates</strong> from all splits are summed together</li>
          <li><strong>The original title</strong> is restored (Roman numerals removed)</li>
          <li><strong>Completed splits</strong> are deleted (their work is already done)</li>
        </ul>
        <p>Use this when you want to reschedule a task differently, or if you finished the work faster than expected.</p>
      </div>
    </details>
    
    <div class="section">
      <div class="section-title">Split Task Groups</div>
      <p class="section-description">
        When AutoPlan splits a task into multiple blocks, you can merge them back together here.
      </p>
      
      <button class="btn" onclick="loadSplitGroups()">
        üîÑ Refresh Split Groups
      </button>

      <div id="splitGroups" style="margin-top: 16px;">
        <p style="opacity: 0.7;">Click "Refresh Split Groups" to load split task groups.</p>
      </div>
    </div>
  </div>

  <script>
    // State
    let currentConfig = {};
    let availableTags = [];
    let availableProjects = [];

    // Handle Dry Run button click
    async function handleDryRun() {
      try {
        // Save current settings first
        await saveSettings();

        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(true);
          const schedule = result.schedule || [];
          const deadlineMisses = result.deadlineMisses || [];
          
          if (deadlineMisses.length > 0) {
            const now = new Date();
            const warnings = deadlineMisses.map(m => {
              const isOverdue = m.dueDate < now;
              const dateStr = m.dueDate.toLocaleDateString();
              return isOverdue 
                ? `"${m.taskTitle}" is overdue (was ${dateStr})`
                : `"${m.taskTitle}" will miss deadline (${dateStr})`;
            }).join('; ');
            showStatus(`‚ö†Ô∏è ${warnings}`, 'warning', true);
          } else {
            showStatus(`Dry Run: ${schedule.length} blocks would be scheduled`, 'success');
          }
          
          // Display the schedule preview
          displaySchedulePreview(schedule);
        } else {
          // AutoPlanAPI not available
          showStatus('AutoPlanAPI not available. Use the header button or Ctrl+Shift+A to run.', 'info');
        }
      } catch (e) {
        console.error('Dry run failed:', e);
        showStatus('Dry run failed: ' + e.message, 'error');
      }
    }

    // Handle Apply Schedule button click
    async function handleApplySchedule() {
      const button = document.getElementById('applyButton');
      const buttonContent = document.getElementById('applyButtonContent');
      const originalContent = buttonContent.innerHTML;

      // Show loading state
      button.disabled = true;
      buttonContent.innerHTML = '<span class="btn-spinner"></span> Running...';

      try {
        // Save current settings first
        await saveSettings();

        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(false);
          const schedule = result.schedule || [];
          const deadlineMisses = result.deadlineMisses || [];
          
          if (deadlineMisses.length > 0) {
            const now = new Date();
            const warnings = deadlineMisses.map(m => {
              const isOverdue = m.dueDate < now;
              const dateStr = m.dueDate.toLocaleDateString();
              return isOverdue 
                ? `"${m.taskTitle}" is overdue (was ${dateStr})`
                : `"${m.taskTitle}" will miss deadline (${dateStr})`;
            }).join('; ');
            showStatus(`‚ö†Ô∏è ${warnings}`, 'warning', true);
          } else {
            showStatus(`AutoPlan complete: ${schedule.length} blocks scheduled`, 'success');
          }
          
          // Refresh the priority list
          await loadTaskPriorities();
        } else {
          // AutoPlanAPI not available
          showStatus('AutoPlanAPI not available. Use the header button or Ctrl+Shift+A to run.', 'info');
        }
      } catch (e) {
        console.error('AutoPlan failed:', e);
        showStatus('AutoPlan failed: ' + e.message, 'error');
      } finally {
        // Restore button state
        button.disabled = false;
        buttonContent.innerHTML = originalContent;
      }
    }

    // Handle Run AutoPlan button click (legacy - kept for compatibility)
    async function handleRunAutoplan() {
      return handleApplySchedule();
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        console.log('[AutoPlan] Tab clicked:', tab.dataset.tab);
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => {
          c.classList.remove('active');
          c.style.display = 'none';
        });
        tab.classList.add('active');
        const tabContent = document.getElementById(`tab-${tab.dataset.tab}`);
        console.log('[AutoPlan] Tab content element:', tabContent, 'classList before:', tabContent?.classList.toString());
        if (tabContent) {
          tabContent.classList.add('active');
          tabContent.style.display = 'block';
          console.log('[AutoPlan] Tab content classList after:', tabContent.classList.toString());
        } else {
          console.error('[AutoPlan] Tab content not found for:', `tab-${tab.dataset.tab}`);
        }
        
        // Auto-load data for specific tabs
        if (tab.dataset.tab === 'merge') {
          loadSplitGroups();
        } else if (tab.dataset.tab === 'priorities') {
          loadTaskPriorities();
        } else if (tab.dataset.tab === 'time-maps') {
          renderTimeMaps();
          renderProjectTimeMapAssignments();
          renderTagTimeMapAssignments();
        }
      });
    });

    // Show status message
    // If persistent=true, shows a close button and doesn't auto-hide
    let statusTimeout = null;
    function showStatus(message, type = 'info', persistent = false) {
      const status = document.getElementById('status');
      
      // Clear any pending auto-hide timeout
      if (statusTimeout) {
        clearTimeout(statusTimeout);
        statusTimeout = null;
      }
      
      if (persistent) {
        status.innerHTML = `<span>${message}</span><button class="status-close" onclick="document.getElementById('status').classList.remove('show')">&times;</button>`;
      } else {
        status.textContent = message;
      }
      
      status.className = `status show ${type}`;
      
      if (!persistent) {
        statusTimeout = setTimeout(() => {
          status.classList.remove('show');
          statusTimeout = null;
        }, 3000);
      }
    }

    // Load settings from plugin
    async function loadSettings() {
      try {
        const data = await PluginAPI.loadSyncedData();
        if (data) {
          currentConfig = JSON.parse(data);
        } else {
          currentConfig = getDefaultConfig();
        }
        // Populate dropdowns before applying settings
        await populateTagDropdown();
        await populateProjectDropdown();
        applySettingsToUI();
        
        // Load priorities on startup
        await loadTaskPriorities();
      } catch (e) {
        console.error('Failed to load settings:', e);
        currentConfig = getDefaultConfig();
        applySettingsToUI();
        
        // Still try to load priorities even if settings fail
        try {
          await loadTaskPriorities();
        } catch (priorityError) {
          console.error('Failed to load priorities:', priorityError);
        }
      }
    }

    // Populate tag dropdowns with available tags
    async function populateTagDropdown() {
      try {
        availableTags = await PluginAPI.getAllTags();
        
        // Populate "Do Not Reschedule" dropdown
        const doNotRescheduleSelect = document.getElementById('doNotRescheduleTag');
        
        // Clear existing options except the first one (None)
        while (doNotRescheduleSelect.options.length > 1) {
          doNotRescheduleSelect.remove(1);
        }
        
        // Add tags as options
        for (const tag of availableTags) {
          const option = document.createElement('option');
          option.value = tag.id;
          option.textContent = tag.title;
          doNotRescheduleSelect.appendChild(option);
        }
        
        // Re-apply the selected value if we have one
        if (currentConfig.doNotRescheduleTagId) {
          doNotRescheduleSelect.value = currentConfig.doNotRescheduleTagId;
        }
        
        // Also populate the tag priority dropdown
        updateTagPriorityDropdown();
      } catch (e) {
        console.error('Failed to load tags:', e);
      }
    }

    // Update the tag priority dropdown with available tags (excluding already added ones)
    function updateTagPriorityDropdown() {
      const select = document.getElementById('newTagName');
      const configuredTags = Object.keys(currentConfig.tagPriorities || {});
      
      // Clear existing options
      select.innerHTML = '<option value="">Select a tag...</option>';
      
      // Add available tags that aren't already configured
      for (const tag of availableTags) {
        if (!configuredTags.includes(tag.title)) {
          const option = document.createElement('option');
          option.value = tag.title;
          option.textContent = tag.title;
          select.appendChild(option);
        }
      }
    }

    // Populate project dropdown with available projects
    async function populateProjectDropdown() {
      try {
        availableProjects = await PluginAPI.getAllProjects();
        updateProjectPriorityDropdown();
      } catch (e) {
        console.error('Failed to load projects:', e);
      }
    }

    // Update the project priority dropdown with available projects (excluding already added ones)
    function updateProjectPriorityDropdown() {
      const select = document.getElementById('newProjectName');
      const configuredProjects = Object.keys(currentConfig.projectPriorities || {});
      
      // Clear existing options
      select.innerHTML = '<option value="">Select a project...</option>';
      
      // Add available projects that aren't already configured
      for (const project of availableProjects) {
        if (!configuredProjects.includes(project.title)) {
          const option = document.createElement('option');
          option.value = project.title;
          option.textContent = project.title;
          select.appendChild(option);
        }
      }
    }

    // Get default config
    function getDefaultConfig() {
      return {
        blockSizeMinutes: 120,
        minimumBlockSizeMinutes: 30,
        tagPriorities: {},
        projectPriorities: {},
        durationFormula: 'linear',
        durationWeight: 1.0,
        oldnessFormula: 'linear',
        oldnessWeight: 1.0,
        deadlineFormula: 'linear',
        deadlineWeight: 12.0,
        maxDaysAhead: 30,
        autoRunOnStart: false,
        splitSuffix: true,
        workdayStartHour: 9,
        workdayHours: 8,
        skipDays: [0, 6], // Sunday and Saturday
        doNotRescheduleTagId: null,
        treatIcalAsFixed: true,
        // Time Maps
        timeMaps: {
          'default': {
            name: 'Default',
            days: {
              0: null,
              1: { startHour: 9, endHour: 17 },
              2: { startHour: 9, endHour: 17 },
              3: { startHour: 9, endHour: 17 },
              4: { startHour: 9, endHour: 17 },
              5: { startHour: 9, endHour: 17 },
              6: null,
            }
          }
        },
        projectTimeMaps: {},
        tagTimeMaps: {},
        defaultTimeMap: 'default',
      };
    }

    // Apply settings to UI
    function applySettingsToUI() {
      document.getElementById('blockSize').value = currentConfig.blockSizeMinutes || 120;
      document.getElementById('minBlockSize').value = currentConfig.minimumBlockSizeMinutes || 30;
      document.getElementById('maxDays').value = currentConfig.maxDaysAhead || 30;
      document.getElementById('autoRun').checked = currentConfig.autoRunOnStart || false;
      document.getElementById('splitSuffix').checked = currentConfig.splitSuffix !== false;
      
      document.getElementById('durationFormula').value = currentConfig.durationFormula || 'linear';
      document.getElementById('durationWeight').value = currentConfig.durationWeight || 1.0;
      document.getElementById('oldnessFormula').value = currentConfig.oldnessFormula || 'linear';
      document.getElementById('oldnessWeight').value = currentConfig.oldnessWeight || 1.0;
      document.getElementById('deadlineFormula').value = currentConfig.deadlineFormula || 'linear';
      document.getElementById('deadlineWeight').value = currentConfig.deadlineWeight ?? 12.0;

      document.getElementById('workdayStartHour').value = currentConfig.workdayStartHour ?? 9;
      document.getElementById('workdayHours').value = currentConfig.workdayHours ?? 8;

      // Apply skip days
      const skipDays = currentConfig.skipDays || [0, 6];
      for (let i = 0; i <= 6; i++) {
        document.getElementById(`skipDay${i}`).checked = skipDays.includes(i);
      }

      // Apply do not reschedule tag (dropdown populated separately)
      const doNotRescheduleSelect = document.getElementById('doNotRescheduleTag');
      if (doNotRescheduleSelect && currentConfig.doNotRescheduleTagId) {
        doNotRescheduleSelect.value = currentConfig.doNotRescheduleTagId;
      }
      
      // Apply treat iCal as fixed setting
      document.getElementById('treatIcalAsFixed').checked = currentConfig.treatIcalAsFixed !== false;

      updateTagTable();
      updateProjectTable();
      updateFormulaPreview();
      
      // Render time maps UI
      renderTimeMaps();
      renderProjectTimeMapAssignments();
      renderTagTimeMapAssignments();
    }

    // Collect settings from UI
    function collectSettingsFromUI() {
      // Collect skip days
      const skipDays = [];
      for (let i = 0; i <= 6; i++) {
        if (document.getElementById(`skipDay${i}`).checked) {
          skipDays.push(i);
        }
      }

      // Get do not reschedule tag
      const doNotRescheduleTagId = document.getElementById('doNotRescheduleTag').value || null;
      
      // Get treat iCal as fixed setting
      const treatIcalAsFixed = document.getElementById('treatIcalAsFixed').checked;

      return {
        blockSizeMinutes: parseInt(document.getElementById('blockSize').value) || 120,
        minimumBlockSizeMinutes: parseInt(document.getElementById('minBlockSize').value) || 30,
        maxDaysAhead: parseInt(document.getElementById('maxDays').value) || 30,
        autoRunOnStart: document.getElementById('autoRun').checked,
        splitSuffix: document.getElementById('splitSuffix').checked,
        durationFormula: document.getElementById('durationFormula').value,
        durationWeight: parseFloat(document.getElementById('durationWeight').value) || 1.0,
        oldnessFormula: document.getElementById('oldnessFormula').value,
        oldnessWeight: parseFloat(document.getElementById('oldnessWeight').value) || 1.0,
        deadlineFormula: document.getElementById('deadlineFormula').value,
        deadlineWeight: parseFloat(document.getElementById('deadlineWeight').value) ?? 12.0,
        workdayStartHour: parseInt(document.getElementById('workdayStartHour').value) || 9,
        workdayHours: parseInt(document.getElementById('workdayHours').value) || 8,
        skipDays: skipDays,
        tagPriorities: currentConfig.tagPriorities || {},
        projectPriorities: currentConfig.projectPriorities || {},
        doNotRescheduleTagId: doNotRescheduleTagId,
        treatIcalAsFixed: treatIcalAsFixed,
        // Time Maps (managed separately, preserve current values)
        timeMaps: currentConfig.timeMaps || getDefaultConfig().timeMaps,
        projectTimeMaps: currentConfig.projectTimeMaps || {},
        tagTimeMaps: currentConfig.tagTimeMaps || {},
        defaultTimeMap: currentConfig.defaultTimeMap || 'default',
      };
    }

    // Save settings
    async function saveSettings() {
      try {
        currentConfig = collectSettingsFromUI();
        await PluginAPI.persistDataSynced(JSON.stringify(currentConfig));
        showStatus('Settings saved successfully!', 'success');
      } catch (e) {
        console.error('Failed to save settings:', e);
        showStatus('Failed to save settings: ' + e.message, 'error');
      }
    }

    // Reset to defaults
    function resetToDefaults() {
      if (confirm('Reset all settings to defaults?')) {
        currentConfig = getDefaultConfig();
        applySettingsToUI();
        showStatus('Settings reset to defaults', 'info');
      }
    }

    // Tag priority management
    function updateTagTable() {
      const tbody = document.getElementById('tagTableBody');
      tbody.innerHTML = '';
      
      const tagPriorities = currentConfig.tagPriorities || {};
      
      for (const [tagName, priority] of Object.entries(tagPriorities)) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><span class="tag-badge">${escapeHtml(tagName)}</span></td>
          <td>
            <input type="number" value="${priority}" 
                   onchange="updateTagPriority('${escapeHtml(tagName)}', this.value)">
          </td>
          <td>
            <button class="btn btn-small" onclick="removeTagPriority('${escapeHtml(tagName)}')">
              Remove
            </button>
          </td>
        `;
        tbody.appendChild(row);
      }

      if (Object.keys(tagPriorities).length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No tag priorities configured</td></tr>';
      }
    }

    function addTagPriority() {
      const nameSelect = document.getElementById('newTagName');
      const priorityInput = document.getElementById('newTagPriority');
      
      const name = nameSelect.value;
      const priority = parseFloat(priorityInput.value) || 0;
      
      if (!name) {
        showStatus('Please select a tag', 'error');
        return;
      }

      if (!currentConfig.tagPriorities) {
        currentConfig.tagPriorities = {};
      }
      
      currentConfig.tagPriorities[name] = priority;
      updateTagTable();
      updateTagPriorityDropdown();
      
      priorityInput.value = '10';
    }

    function updateTagPriority(name, value) {
      currentConfig.tagPriorities[name] = parseFloat(value) || 0;
    }

    function removeTagPriority(name) {
      delete currentConfig.tagPriorities[name];
      updateTagTable();
      updateTagPriorityDropdown();
    }

    // Project priority management
    function updateProjectTable() {
      const tbody = document.getElementById('projectTableBody');
      tbody.innerHTML = '';
      
      const projectPriorities = currentConfig.projectPriorities || {};
      
      for (const [projectName, priority] of Object.entries(projectPriorities)) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><span class="tag-badge">${escapeHtml(projectName)}</span></td>
          <td>
            <input type="number" value="${priority}" 
                   onchange="updateProjectPriority('${escapeHtml(projectName)}', this.value)">
          </td>
          <td>
            <button class="btn btn-small" onclick="removeProjectPriority('${escapeHtml(projectName)}')">
              Remove
            </button>
          </td>
        `;
        tbody.appendChild(row);
      }

      if (Object.keys(projectPriorities).length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No project priorities configured</td></tr>';
      }
    }

    function addProjectPriority() {
      const nameSelect = document.getElementById('newProjectName');
      const priorityInput = document.getElementById('newProjectPriority');
      
      const name = nameSelect.value;
      const priority = parseFloat(priorityInput.value) || 0;
      
      if (!name) {
        showStatus('Please select a project', 'error');
        return;
      }

      if (!currentConfig.projectPriorities) {
        currentConfig.projectPriorities = {};
      }
      
      currentConfig.projectPriorities[name] = priority;
      updateProjectTable();
      updateProjectPriorityDropdown();
      
      priorityInput.value = '10';
    }

    function updateProjectPriority(name, value) {
      currentConfig.projectPriorities[name] = parseFloat(value) || 0;
    }

    function removeProjectPriority(name) {
      delete currentConfig.projectPriorities[name];
      updateProjectTable();
      updateProjectPriorityDropdown();
    }



    // Formula preview update
    function updateFormulaPreview() {
      const durationFormula = document.getElementById('durationFormula').value;
      const durationWeight = document.getElementById('durationWeight').value;
      const oldnessFormula = document.getElementById('oldnessFormula').value;
      const oldnessWeight = document.getElementById('oldnessWeight').value;
      const deadlineFormula = document.getElementById('deadlineFormula').value;
      const deadlineWeight = document.getElementById('deadlineWeight').value;

      const durationFns = {
        none: 'disabled',
        linear: 'hours',
        inverse: '1/(hours+1)',
        log: 'log(hours+1)'
      };

      const oldnessFns = {
        none: 'disabled',
        linear: 'days',
        log: 'log(days+1)',
        exponential: '1.1^days'
      };

      const deadlineFns = {
        none: 'disabled',
        linear: 'linear(days_until_due)',
        aggressive: 'aggressive(days_until_due)'
      };

      document.getElementById('durationPreview').textContent = 
        `Duration Priority = ${durationFns[durationFormula]} * ${durationWeight}`;
      document.getElementById('oldnessPreview').textContent = 
        `Oldness Priority = ${oldnessFns[oldnessFormula]} * ${oldnessWeight}`;
      document.getElementById('deadlinePreview').textContent = 
        `Deadline Priority = ${deadlineFns[deadlineFormula]} * ${deadlineWeight}`;
    }

    // Add event listeners for formula preview
    ['durationFormula', 'durationWeight', 'oldnessFormula', 'oldnessWeight', 'deadlineFormula', 'deadlineWeight'].forEach(id => {
      document.getElementById(id).addEventListener('change', updateFormulaPreview);
    });

    // Schedule preview
    async function previewSchedule() {
      const container = document.getElementById('schedulePreview');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Generating schedule preview...</div>';

      try {
        // Save current settings first
        await saveSettings();

        // Try to use the full preview from plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(true); // dry run
          const schedule = result.schedule || [];

          if (schedule.length === 0) {
            container.innerHTML = '<p style="opacity: 0.7;">No tasks to schedule. Make sure tasks have time estimates.</p>';
            return;
          }

          // Group by date for better display
          const byDate = new Map();
          for (const item of schedule) {
            const dateStr = item.startTime.toLocaleDateString();
            if (!byDate.has(dateStr)) {
              byDate.set(dateStr, []);
            }
            byDate.get(dateStr).push(item);
          }

          let html = '';
          
          html += `<p style="margin-bottom: 12px; font-weight: 500;">${schedule.length} blocks scheduled across ${byDate.size} days:</p>`;
          
          for (const [date, items] of byDate) {
            html += `<div style="margin-top: 12px; margin-bottom: 8px; font-weight: 600; opacity: 0.8;">${date}</div>`;
            for (const item of items) {
              const startTime = item.startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const endTime = item.endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const hours = (item.split.estimatedHours).toFixed(1);
              
              html += `
                <div class="schedule-item">
                  <div class="schedule-title">
                    <span style="opacity: 0.6; font-size: 0.9em;">${startTime}-${endTime}</span>
                    ${escapeHtml(item.split.title)}
                  </div>
                  <div class="schedule-urgency">${hours}h</div>
                </div>
              `;
            }
          }

          container.innerHTML = html;
        } else {
          // Fallback: just show eligible tasks
          const tasks = await PluginAPI.getTasks();
          const eligibleTasks = tasks.filter(t => !t.isDone && t.timeEstimate && t.timeEstimate > 0);

          if (eligibleTasks.length === 0) {
            container.innerHTML = '<p style="opacity: 0.7;">No tasks with time estimates found</p>';
            return;
          }

          container.innerHTML = `
            <p style="margin-bottom: 12px;">Found ${eligibleTasks.length} tasks with time estimates:</p>
            ${eligibleTasks.slice(0, 10).map(task => `
              <div class="schedule-item">
                <div class="schedule-title">${escapeHtml(task.title)}</div>
                <div class="schedule-urgency">${Math.round((task.timeEstimate || 0) / 3600000)}h</div>
              </div>
            `).join('')}
            ${eligibleTasks.length > 10 ? `<p style="opacity: 0.7;">...and ${eligibleTasks.length - 10} more tasks</p>` : ''}
            <p style="margin-top: 12px; opacity: 0.7; font-size: 0.9em;">Note: Full preview requires plugin.js to be loaded.</p>
          `;
        }
      } catch (e) {
        console.error('Preview failed:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Run autoplan
    async function runAutoplan() {
      try {
        await saveSettings();
        
        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.runAutoplan(false);
          const deadlineMisses = result.deadlineMisses || [];
          
          if (deadlineMisses.length > 0) {
            const now = new Date();
            const warnings = deadlineMisses.map(m => {
              const isOverdue = m.dueDate < now;
              const dateStr = m.dueDate.toLocaleDateString();
              return isOverdue 
                ? `"${m.taskTitle}" is overdue (was ${dateStr})`
                : `"${m.taskTitle}" will miss deadline (${dateStr})`;
            }).join('; ');
            showStatus(`‚ö†Ô∏è ${warnings}`, 'warning', true);
          } else {
            showStatus(`AutoPlan complete: ${result.schedule?.length || 0} blocks scheduled`, 'success');
          }
        } else {
          // Fallback: Show instructions
          showStatus('Please use the AutoPlan header button or Ctrl+Shift+A to run the scheduler', 'info');
        }
      } catch (e) {
        console.error('AutoPlan failed:', e);
        showStatus('AutoPlan failed: ' + e.message, 'error');
      }
    }

    // Show the clear planning confirmation modal
    function showClearPlanningModal() {
      document.getElementById('clearPlanningModal').classList.add('show');
    }

    // Hide the clear planning confirmation modal
    function hideClearPlanningModal(event) {
      // If called from overlay click, only hide if clicking the overlay itself
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('clearPlanningModal').classList.remove('show');
    }

    // Confirm and execute clear planning
    async function confirmClearPlanning() {
      hideClearPlanningModal();
      
      try {
        // Try to communicate with plugin.js
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.clearPlanning();
          let message = '';
          if (result.merged > 0 && result.cleared > 0) {
            message = `Merged ${result.merged} split groups, cleared planning from ${result.cleared} tasks`;
          } else if (result.merged > 0) {
            message = `Merged ${result.merged} split groups`;
          } else if (result.cleared > 0) {
            message = `Cleared planning from ${result.cleared} tasks`;
          } else {
            message = 'No tasks to clear';
          }
          showStatus(message, 'success');
          
          // Refresh the priority list if we're on that tab
          await loadTaskPriorities();
        } else {
          // Fallback: Show instructions
          showStatus('AutoPlanAPI not available. Make sure the plugin is properly loaded.', 'error');
        }
      } catch (e) {
        console.error('Clear planning failed:', e);
        showStatus('Clear planning failed: ' + e.message, 'error');
      }
    }

    // Load and display split groups
    async function loadSplitGroups() {
      console.log('[AutoPlan] loadSplitGroups called');
      const container = document.getElementById('splitGroups');
      if (!container) {
        console.error('[AutoPlan] splitGroups container not found');
        return;
      }
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading split groups...</div>';

      try {
        // Check if PluginAPI is available
        if (typeof PluginAPI === 'undefined') {
          container.innerHTML = '<p style="color: #ff6b6b;">PluginAPI not available. Make sure the plugin is properly loaded.</p>';
          return;
        }
        
        // Get all tasks and find split groups
        const tasks = await PluginAPI.getTasks();
        console.log('[AutoPlan] loadSplitGroups: Found', tasks.length, 'tasks');
        const groups = findSplitGroups(tasks);
        console.log('[AutoPlan] loadSplitGroups: Found', groups.length, 'split groups');

        if (groups.length === 0) {
          container.innerHTML = '<p style="opacity: 0.7;">No split task groups found. Split tasks are created when AutoPlan breaks a large task into smaller time blocks.</p>';
          return;
        }

        // Build a map of task ID to task for quick parent lookup
        const taskMap = new Map();
        for (const task of tasks) {
          taskMap.set(task.id, task);
        }
        
        // Helper function to get display title with parent prefix
        function getDisplayTitle(task) {
          let title = task.title;
          if (task.parentId) {
            const parent = taskMap.get(task.parentId);
            if (parent) {
              title = `${parent.title} > ${task.title}`;
            }
          }
          return title;
        }
        
        // Helper function to get original title with parent prefix
        function getOriginalDisplayTitle(group) {
          // Find the first split task to check for parent
          const firstSplit = group.splits[0]?.task;
          if (firstSplit && firstSplit.parentId) {
            const parent = taskMap.get(firstSplit.parentId);
            if (parent) {
              return `${parent.title} > ${group.originalTitle}`;
            }
          }
          return group.originalTitle;
        }

        const html = groups.map(group => {
          const incompleteSplits = group.splits.filter(s => !s.task.isDone);
          const completedSplits = group.splits.filter(s => s.task.isDone);
          const totalRemaining = incompleteSplits.reduce((sum, s) => sum + (s.task.timeEstimate || 0), 0);
          const displayTitle = getOriginalDisplayTitle(group);
          
          return `
            <div class="section" style="margin-bottom: 12px;">
              <div class="section-title">${escapeHtml(displayTitle)}</div>
              <div style="display: flex; gap: 16px; margin-bottom: 12px;">
                <span style="opacity: 0.7;">
                  ${incompleteSplits.length} incomplete / ${completedSplits.length} completed
                </span>
                <span style="font-weight: 500;">
                  ${Math.round(totalRemaining / 3600000)}h remaining
                </span>
              </div>
              <div style="margin-bottom: 12px;">
                ${group.splits.map(s => `
                  <div class="schedule-item" style="opacity: ${s.task.isDone ? '0.5' : '1'};">
                    <div class="schedule-title">
                      ${s.task.isDone ? '&#x2713; ' : ''}${escapeHtml(getDisplayTitle(s.task))}
                    </div>
                    <div class="schedule-urgency">
                      ${Math.round((s.task.timeEstimate || 0) / 3600000)}h
                    </div>
                  </div>
                `).join('')}
              </div>
              ${incompleteSplits.length > 1 ? `
                <button class="btn btn-small" onclick="mergeSplitGroup('${group.splits[0].task.id}')">
                  Merge ${incompleteSplits.length} Incomplete Splits
                </button>
              ` : `
                <span style="opacity: 0.7; font-size: 0.85em;">
                  ${incompleteSplits.length === 1 ? 'Only 1 incomplete split remaining' : 'All splits completed'}
                </span>
              `}
            </div>
          `;
        }).join('');
        
        console.log('[AutoPlan] Generated HTML length:', html.length);
        container.innerHTML = html;
        console.log('[AutoPlan] Container innerHTML set, children:', container.children.length);
      } catch (e) {
        console.error('Failed to load split groups:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Find split groups from tasks
    function findSplitGroups(tasks) {
      const groups = new Map();

      for (const task of tasks) {
        const splitInfo = parseSplitInfo(task);
        if (splitInfo) {
          if (!groups.has(splitInfo.originalTaskId)) {
            groups.set(splitInfo.originalTaskId, {
              originalTaskId: splitInfo.originalTaskId,
              originalTitle: splitInfo.originalTitle,
              splits: [],
            });
          }
          groups.get(splitInfo.originalTaskId).splits.push({
            task,
            splitInfo,
          });
        }
      }

      // Sort splits within each group
      for (const group of groups.values()) {
        group.splits.sort((a, b) => a.splitInfo.splitIndex - b.splitInfo.splitIndex);
      }

      return Array.from(groups.values());
    }

    // Parse split info from task notes
    function parseSplitInfo(task) {
      if (!task.notes) return null;
      
      // Look for the AutoPlan split marker with [AutoPlan] prefix
      // This prevents false positives from user notes that happen to match the pattern
      // Handle potential special characters in title
      const splitMatch = task.notes.match(/\[AutoPlan\] Split (\d+)\/(\d+) of "((?:[^"\\]|\\.)*)"/);
      const idMatch = task.notes.match(/\[AutoPlan\] Original Task ID: ([^\n\s]+)/);
      
      if (splitMatch && idMatch) {
        return {
          splitIndex: parseInt(splitMatch[1]) - 1,
          totalSplits: parseInt(splitMatch[2]),
          originalTitle: splitMatch[3].replace(/\\"/g, '"'), // Unescape quotes
          originalTaskId: idMatch[1].trim(),
        };
      }
      return null;
    }

    // Merge a split group
    async function mergeSplitGroup(taskId) {
      if (!confirm('Merge all incomplete splits of this task into one?')) {
        return;
      }

      try {
        if (window.parent && window.parent.AutoPlanAPI) {
          const result = await window.parent.AutoPlanAPI.mergeSplits(taskId);
          if (result) {
            showStatus(`Merged ${result.mergedCount} splits successfully`, 'success');
            loadSplitGroups(); // Refresh the list
          }
        } else {
          // Manual merge fallback
          const tasks = await PluginAPI.getTasks();
          const task = tasks.find(t => t.id === taskId);
          
          if (!task) {
            showStatus('Task not found', 'error');
            return;
          }

          const splitInfo = parseSplitInfo(task);
          if (!splitInfo) {
            showStatus('Not a split task', 'error');
            return;
          }

          // Find related splits
          const relatedSplits = tasks.filter(t => {
            const info = parseSplitInfo(t);
            return info && info.originalTaskId === splitInfo.originalTaskId && !t.isDone;
          });

          if (relatedSplits.length <= 1) {
            showStatus('Nothing to merge', 'info');
            return;
          }

          // Calculate totals
          let totalEstimate = 0;
          let totalSpent = 0;
          for (const split of relatedSplits) {
            totalEstimate += split.timeEstimate || 0;
            totalSpent += split.timeSpent || 0;
          }

          // Use first split as merged task
          relatedSplits.sort((a, b) => {
            const infoA = parseSplitInfo(a);
            const infoB = parseSplitInfo(b);
            return (infoA?.splitIndex || 0) - (infoB?.splitIndex || 0);
          });

          const mergedTask = relatedSplits[0];
          const toDelete = relatedSplits.slice(1);

          // Update merged task
          await PluginAPI.updateTask(mergedTask.id, {
            title: splitInfo.originalTitle,
            timeEstimate: totalEstimate,
            timeSpent: totalSpent,
            notes: `[AutoPlan] Merged from ${relatedSplits.length} split tasks.`,
          });

          // Delete the other splits
          for (const t of toDelete) {
            try {
              await PluginAPI.deleteTask(t.id);
            } catch (e) {
              console.warn('Could not delete task:', e);
              // Fallback: mark as done
              await PluginAPI.updateTask(t.id, {
                isDone: true,
                notes: `${t.notes || ''}\n\n[AutoPlan] Merged into task: ${mergedTask.id}`,
              });
            }
          }

          showStatus(`Merged ${relatedSplits.length} splits`, 'success');
          loadSplitGroups();
        }
      } catch (e) {
        console.error('Merge failed:', e);
        showStatus('Merge failed: ' + e.message, 'error');
      }
    }

    // Utility: escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load and display task priorities
    async function loadTaskPriorities() {
      const container = document.getElementById('prioritiesList');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading task priorities...</div>';

      try {
        // Get current config for priority calculation
        const configData = await PluginAPI.loadSyncedData();
        const config = configData ? JSON.parse(configData) : getDefaultConfig();
        
        // Get all tasks, tags, and projects
        const tasks = await PluginAPI.getTasks();
        const allTags = await PluginAPI.getAllTags();
        const allProjects = await PluginAPI.getAllProjects();
        
        // Find parent task IDs (tasks that have subtasks)
        const parentIds = new Set();
        for (const task of tasks) {
          if (task.parentId) {
            parentIds.add(task.parentId);
          }
        }
        
        // Build a map of task ID to task for quick parent lookup
        const taskMap = new Map();
        for (const task of tasks) {
          taskMap.set(task.id, task);
        }
        
        // Group split tasks by their original task ID
        const splitGroups = new Map(); // originalTaskId -> { originalTitle, splits: [...] }
        const nonSplitTasks = [];
        
        // Check if iCal tasks should be treated as fixed
        const treatIcalAsFixed = config.treatIcalAsFixed !== false;
        
        for (const task of tasks) {
          if (task.isDone) continue;
          if (!task.timeEstimate || task.timeEstimate <= 0) continue;
          if (parentIds.has(task.id)) continue; // Skip parent tasks
          
          // Skip iCal tasks if the setting is enabled
          if (treatIcalAsFixed && task.issueType === 'ICAL') continue;
          
          const splitInfo = parseSplitInfo(task);
          if (splitInfo) {
            // This is a split task - group it
            if (!splitGroups.has(splitInfo.originalTaskId)) {
              splitGroups.set(splitInfo.originalTaskId, {
                originalTaskId: splitInfo.originalTaskId,
                originalTitle: splitInfo.originalTitle,
                splits: [],
                // Use the first split's properties for priority calculation
                representativeTask: task
              });
            }
            splitGroups.get(splitInfo.originalTaskId).splits.push(task);
          } else {
            // Regular task (not a split)
            nonSplitTasks.push(task);
          }
        }
        
        // Build the list of tasks to display (original tasks with combined durations)
        const displayTasks = [];
        
        // Add non-split tasks as-is
        for (const task of nonSplitTasks) {
          displayTasks.push({
            task,
            displayTitle: task.title,
            totalEstimate: task.timeEstimate || 0,
            isSplitGroup: false
          });
        }
        
        // Add split groups as consolidated original tasks
        for (const group of splitGroups.values()) {
          // Sum up time estimates from all incomplete splits
          const totalEstimate = group.splits.reduce((sum, t) => sum + (t.timeEstimate || 0), 0);
          
          // Create a virtual task representing the original
          displayTasks.push({
            task: group.representativeTask, // Use for priority calculation
            displayTitle: group.originalTitle,
            totalEstimate,
            isSplitGroup: true,
            splitCount: group.splits.length
          });
        }

        if (displayTasks.length === 0) {
          container.innerHTML = '<p style="opacity: 0.7;">No eligible tasks found. Tasks must have time estimates to be scheduled.</p>';
          return;
        }

        // Calculate priority for each task
        const now = new Date();
        const tasksWithPriority = displayTasks.map(item => {
          // Create a virtual task with the correct total time estimate for priority calculation
          const taskForCalculation = {
            ...item.task,
            timeEstimate: item.totalEstimate
          };
          const urgency = calculateTaskUrgency(taskForCalculation, config, allTags, allProjects, tasks, now);
          return {
            ...item,
            urgency: urgency.total,
            components: urgency.components
          };
        });

        // Sort by priority (highest first)
        tasksWithPriority.sort((a, b) => b.urgency - a.urgency);

        // Build HTML
        let html = `<p style="margin-bottom: 12px; font-weight: 500;">${tasksWithPriority.length} tasks sorted by priority:</p>`;
        
        for (const item of tasksWithPriority) {
          const { task, displayTitle, totalEstimate, urgency, components, isSplitGroup, splitCount } = item;
          const hours = Math.round(totalEstimate / 3600000 * 10) / 10;
          
          // Build display title with parent prefix for subtasks
          let fullDisplayTitle = displayTitle;
          if (task.parentId) {
            const parent = taskMap.get(task.parentId);
            if (parent) {
              fullDisplayTitle = `${parent.title} > ${displayTitle}`;
            }
          }
          
          // Build explanation parts (only show non-zero components)
          const explanationParts = [];
          if (components.tag !== 0) explanationParts.push(`tag: ${formatNumber(components.tag)}`);
          if (components.project !== 0) explanationParts.push(`project: ${formatNumber(components.project)}`);
          if (components.duration !== 0) explanationParts.push(`duration: ${formatNumber(components.duration)}`);
          if (components.oldness !== 0) explanationParts.push(`oldness: ${formatNumber(components.oldness)}`);
          if (components.deadline !== 0) explanationParts.push(`deadline: ${formatNumber(components.deadline)}`);
          
          const explanation = explanationParts.length > 0 
            ? explanationParts.join(' + ') 
            : 'no priority factors applied';
          
          // Add split indicator if this is a consolidated split group
          const splitIndicator = isSplitGroup ? ` (${splitCount} splits)` : '';
          
          html += `
            <div class="priority-item">
              <div class="priority-header">
                <div class="priority-title">${escapeHtml(fullDisplayTitle)}${splitIndicator}</div>
                <div class="priority-score">${formatNumber(urgency)}</div>
              </div>
              <div class="priority-explanation">${hours}h est. | ${explanation}</div>
            </div>
          `;
        }

        container.innerHTML = html;
      } catch (e) {
        console.error('Failed to load priorities:', e);
        container.innerHTML = `<p style="font-weight: bold;">Error: ${e.message}</p>`;
      }
    }

    // Format number for display (1 decimal place, remove trailing zeros)
    function formatNumber(num) {
      if (num === 0) return '0';
      const rounded = Math.round(num * 10) / 10;
      return rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(1);
    }

    // Display schedule preview from dry run results
    function displaySchedulePreview(schedule) {
      const section = document.getElementById('schedulePreviewSection');
      const container = document.getElementById('schedulePreview');
      
      if (!schedule || schedule.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      // Show the section
      section.style.display = 'block';
      
      // Group schedule by day
      const dayGroups = new Map(); // dateString -> items[]
      let totalMinutes = 0;
      const uniqueTasks = new Set();
      
      for (const item of schedule) {
        const dateStr = item.startTime.toLocaleDateString('en-US', { 
          weekday: 'short', 
          month: 'short', 
          day: 'numeric' 
        });
        
        if (!dayGroups.has(dateStr)) {
          dayGroups.set(dateStr, []);
        }
        dayGroups.get(dateStr).push(item);
        
        // Track stats
        const durationMs = item.endTime - item.startTime;
        totalMinutes += durationMs / 60000;
        uniqueTasks.add(item.split.originalTaskId);
      }
      
      // Build summary
      const totalHours = Math.round(totalMinutes / 6) / 10; // Round to 1 decimal
      const daysCount = dayGroups.size;
      const firstDay = schedule[0].startTime.toLocaleDateString();
      const lastDay = schedule[schedule.length - 1].startTime.toLocaleDateString();
      
      let html = `
        <div class="schedule-summary">
          <div class="schedule-summary-row">
            <span>Total blocks:</span>
            <strong>${schedule.length}</strong>
          </div>
          <div class="schedule-summary-row">
            <span>Total time:</span>
            <strong>${totalHours} hours</strong>
          </div>
          <div class="schedule-summary-row">
            <span>Unique tasks:</span>
            <strong>${uniqueTasks.size}</strong>
          </div>
          <div class="schedule-summary-row">
            <span>Date range:</span>
            <strong>${firstDay} - ${lastDay} (${daysCount} days)</strong>
          </div>
        </div>
        <div class="schedule-preview">
      `;
      
      // Build day-by-day schedule
      for (const [dateStr, items] of dayGroups) {
        html += `
          <div class="schedule-day">
            <div class="schedule-day-header">${dateStr}</div>
        `;
        
        for (const item of items) {
          const startTimeStr = item.startTime.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
          });
          const endTimeStr = item.endTime.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
          });
          
          // Get task title (use original title for splits)
          const title = item.split.originalTitle || item.split.title || 'Untitled';
          const splitLabel = item.split.splitIndex > 0 ? ` [${item.split.splitIndex + 1}/${item.split.totalSplits || '?'}]` : '';
          
          html += `
            <div class="schedule-item">
              <span class="schedule-time">${startTimeStr} - ${endTimeStr}</span>
              <span class="schedule-title">${escapeHtml(title)}${splitLabel}</span>
              <span class="schedule-urgency" title="Priority score">${formatNumber(item.urgency)}</span>
            </div>
          `;
        }
        
        html += '</div>'; // close schedule-day
      }
      
      html += '</div>'; // close schedule-preview
      container.innerHTML = html;
      
      // Scroll the section into view
      section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // Calculate task urgency (mirrors PriorityCalculator.calculateUrgency from core.js)
    function calculateTaskUrgency(task, config, allTags, allProjects, allTasks, now) {
      const tagPriority = calculateTagPriority(task, config.tagPriorities || {}, allTags, allTasks);
      const projectPriority = calculateProjectPriority(task, config.projectPriorities || {}, allProjects);
      const durationPriority = calculateDurationPriority(task, config.durationFormula || 'none', config.durationWeight ?? 1.0);
      const oldnessPriority = calculateOldnessPriority(task, config.oldnessFormula || 'none', config.oldnessWeight ?? 1.0, now);
      const deadlinePriority = calculateDeadlinePriority(task, config.deadlineFormula || 'linear', config.deadlineWeight ?? 12.0, now);

      // Apply urgencyWeight to non-deadline factors
      const urgencyWeight = config.urgencyWeight ?? 1.0;
      const nonDeadlineUrgency = (tagPriority + projectPriority + durationPriority + oldnessPriority) * urgencyWeight;

      return {
        total: nonDeadlineUrgency + deadlinePriority,
        components: {
          tag: tagPriority * urgencyWeight,
          project: projectPriority * urgencyWeight,
          duration: durationPriority * urgencyWeight,
          oldness: oldnessPriority * urgencyWeight,
          deadline: deadlinePriority
        }
      };
    }

    // Get effective tag IDs including inherited from parent
    function getEffectiveTagIds(task, allTasks) {
      const tagIds = new Set(task.tagIds || []);
      if (task.parentId && allTasks) {
        const parent = allTasks.find(t => t.id === task.parentId);
        if (parent) {
          const parentTags = getEffectiveTagIds(parent, allTasks);
          for (const tagId of parentTags) {
            tagIds.add(tagId);
          }
        }
      }
      return Array.from(tagIds);
    }

    // Calculate tag-based priority boost
    function calculateTagPriority(task, tagPriorities, allTags, allTasks) {
      const effectiveTagIds = getEffectiveTagIds(task, allTasks);
      if (effectiveTagIds.length === 0) return 0;
      if (!tagPriorities || typeof tagPriorities !== 'object') return 0;
      
      let boost = 0;
      for (const tagId of effectiveTagIds) {
        const tag = allTags.find(t => t.id === tagId);
        if (tag && tagPriorities[tag.title] !== undefined) {
          boost += Number(tagPriorities[tag.title]) || 0;
        }
      }
      return boost;
    }

    // Calculate project-based priority boost
    function calculateProjectPriority(task, projectPriorities, allProjects) {
      if (!task.projectId) return 0;
      if (!projectPriorities || typeof projectPriorities !== 'object') return 0;
      
      const project = allProjects.find(p => p.id === task.projectId);
      if (project && projectPriorities[project.title] !== undefined) {
        return Number(projectPriorities[project.title]) || 0;
      }
      return 0;
    }

    // Get remaining hours for task
    function getRemainingHours(task) {
      const estimated = (task.timeEstimate || 0) / (1000 * 60 * 60);
      const spent = (task.timeSpent || 0) / (1000 * 60 * 60);
      return Math.max(0, estimated - spent);
    }

    // Calculate duration-based priority factor
    function calculateDurationPriority(task, formula, weight) {
      const hours = getRemainingHours(task);
      if (hours <= 0 || formula === 'none') return 0;
      if (weight <= 0) return 0;

      let factor;
      switch (formula) {
        case 'inverse':
          factor = 1 / (hours + 1);
          break;
        case 'log':
          factor = Math.log(hours + 1);
          break;
        case 'linear':
        default:
          factor = hours;
          break;
      }
      return factor * weight;
    }

    // Get task age in days
    function getTaskAgeInDays(task, now) {
      if (!task.created) return 0;
      const created = new Date(task.created);
      return Math.abs(now - created) / (1000 * 60 * 60 * 24);
    }

    // Calculate oldness-based priority factor
    function calculateOldnessPriority(task, formula, weight, now) {
      const days = getTaskAgeInDays(task, now);
      if (days <= 0 || formula === 'none') return 0;
      if (weight <= 0) return 0;

      let factor;
      switch (formula) {
        case 'exponential':
          const cappedDays = Math.min(days, 100);
          factor = Math.pow(1.1, cappedDays);
          break;
        case 'log':
          factor = Math.log(days + 1);
          break;
        case 'linear':
        default:
          factor = days;
          break;
      }
      return factor * weight;
    }

    // Parse deadline from task notes
    function parseDeadlineFromNotes(notes) {
      if (!notes || typeof notes !== 'string') return null;
      
      const patterns = [
        /(?:deadline)\s*:\s*(\d{4}-\d{2}-\d{2})/i,
        /(?:deadline)\s*:\s*([A-Za-z]{3,9}\s+\d{1,2},?\s+\d{4})/i,
        /(?:deadline)\s*:\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
      ];
      
      for (const pattern of patterns) {
        const match = notes.match(pattern);
        if (match) {
          const dateStr = match[1];
          if (dateStr.includes('/')) {
            const parts = dateStr.split('/');
            if (parts.length === 3) {
              const [first, second, year] = parts.map(p => parseInt(p, 10));
              if (first > 12 && second >= 1 && second <= 12) {
                return new Date(year, second - 1, first);
              }
              if (first >= 1 && first <= 12 && second >= 1 && second <= 31) {
                return new Date(year, first - 1, second);
              }
            }
          } else {
            const parsed = new Date(dateStr);
            if (!isNaN(parsed.getTime())) {
              return parsed;
            }
          }
        }
      }
      return null;
    }

    // Get task due date
    function getTaskDueDate(task) {
      const notesDeadline = parseDeadlineFromNotes(task.notes);
      if (notesDeadline) return notesDeadline;
      if (task.dueDate) return new Date(task.dueDate);
      return null;
    }

    // Calculate deadline-based priority factor
    function calculateDeadlinePriority(task, formula, weight, now) {
      if (formula === 'none') return 0;
      if (weight <= 0) return 0;

      const dueDate = getTaskDueDate(task);
      if (!dueDate) return 0;

      const daysUntilDue = (dueDate - now) / (1000 * 60 * 60 * 24);

      let factor;
      switch (formula) {
        case 'aggressive':
          if (daysUntilDue <= -7) {
            factor = 1.0;
          } else if (daysUntilDue <= 0) {
            factor = 0.9 + (-daysUntilDue / 7) * 0.1;
          } else if (daysUntilDue <= 7) {
            factor = 0.9 - (daysUntilDue / 7) * 0.4;
          } else if (daysUntilDue <= 14) {
            factor = 0.5 - ((daysUntilDue - 7) / 7) * 0.3;
          } else {
            factor = 0.2;
          }
          break;
        case 'linear':
        default:
          if (daysUntilDue <= -7) {
            factor = 1.0;
          } else if (daysUntilDue >= 14) {
            factor = 0.2;
          } else {
            factor = 1.0 - ((daysUntilDue + 7) / 21) * 0.8;
          }
          break;
      }

      return factor * weight;
    }

    // ============================================================================
    // TIME MAPS MANAGEMENT
    // ============================================================================

    const DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const DAY_ABBREV = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    let editingTimeMapId = null; // Track which time map we're editing (null for new)

    // Get default time map structure
    function getDefaultTimeMap() {
      return {
        name: 'New Time Map',
        days: {
          0: null,  // Sunday: skip
          1: { startHour: 9, endHour: 17 },
          2: { startHour: 9, endHour: 17 },
          3: { startHour: 9, endHour: 17 },
          4: { startHour: 9, endHour: 17 },
          5: { startHour: 9, endHour: 17 },
          6: null,  // Saturday: skip
        }
      };
    }

    // Generate a unique ID for a time map
    function generateTimeMapId(name) {
      const base = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
      const existing = Object.keys(currentConfig.timeMaps || {});
      let id = base || 'time-map';
      let counter = 1;
      while (existing.includes(id)) {
        id = `${base}-${counter}`;
        counter++;
      }
      return id;
    }

    // Initialize time maps in config if not present
    function ensureTimeMapsConfig() {
      if (!currentConfig.timeMaps) {
        // Create default time map from legacy settings
        currentConfig.timeMaps = {
          'default': createTimeMapFromLegacy(currentConfig)
        };
      }
      if (!currentConfig.projectTimeMaps) {
        currentConfig.projectTimeMaps = {};
      }
      if (!currentConfig.defaultTimeMap) {
        currentConfig.defaultTimeMap = 'default';
      }
    }

    // Create time map from legacy workday settings
    function createTimeMapFromLegacy(config) {
      const startHour = config.workdayStartHour ?? 9;
      const hours = config.workdayHours ?? 8;
      const endHour = startHour + hours;
      const skipDays = config.skipDays ?? [0, 6];
      
      const days = {};
      for (let day = 0; day < 7; day++) {
        if (skipDays.includes(day)) {
          days[day] = null;
        } else {
          days[day] = { startHour, endHour };
        }
      }
      
      return { name: 'Default', days };
    }

    // Format hours for display (e.g., "9-17" or "9am-5pm")
    function formatHours(daySchedule) {
      if (!daySchedule) return 'Off';
      const start = daySchedule.startHour;
      const end = daySchedule.endHour;
      return `${start}:00-${end}:00`;
    }

    // Render all time maps in the UI
    function renderTimeMaps() {
      ensureTimeMapsConfig();
      const container = document.getElementById('timeMapsContainer');
      if (!container) return;

      const timeMaps = currentConfig.timeMaps || {};
      
      if (Object.keys(timeMaps).length === 0) {
        container.innerHTML = '<p style="opacity: 0.7;">No time maps configured. Click "Add Time Map" to create one.</p>';
        return;
      }

      let html = '';
      for (const [id, timeMap] of Object.entries(timeMaps)) {
        const isDefault = id === currentConfig.defaultTimeMap;
        html += `
          <div class="time-map-card">
            <div class="time-map-header">
              <span class="time-map-name">${escapeHtml(timeMap.name)}${isDefault ? ' (default)' : ''}</span>
              <div class="time-map-actions">
                <button class="btn btn-small" onclick="editTimeMap('${escapeHtml(id)}')">Edit</button>
                ${id !== 'default' ? `<button class="btn btn-small btn-danger" onclick="deleteTimeMap('${escapeHtml(id)}')">Delete</button>` : ''}
              </div>
            </div>
            <div class="time-map-schedule">
              ${[0, 1, 2, 3, 4, 5, 6].map(day => {
                const daySchedule = timeMap.days[day];
                const isSkip = !daySchedule;
                return `
                  <div class="time-map-day${isSkip ? ' skip' : ''}">
                    <div class="time-map-day-name">${DAY_ABBREV[day]}</div>
                    <div class="time-map-day-hours">${isSkip ? 'Off' : formatHours(daySchedule)}</div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }
      
      container.innerHTML = html;
      
      // Update dropdowns
      updateTimeMapDropdowns();
    }

    // Update all time map-related dropdowns
    function updateTimeMapDropdowns() {
      ensureTimeMapsConfig();
      const timeMaps = currentConfig.timeMaps || {};
      
      // Default time map dropdown
      const defaultSelect = document.getElementById('defaultTimeMapSelect');
      if (defaultSelect) {
        const currentValue = defaultSelect.value || currentConfig.defaultTimeMap;
        defaultSelect.innerHTML = Object.entries(timeMaps).map(([id, tm]) => 
          `<option value="${escapeHtml(id)}"${id === currentValue ? ' selected' : ''}>${escapeHtml(tm.name)}</option>`
        ).join('');
      }
      
      // New assignment time map dropdown
      const newTimeMapSelect = document.getElementById('newProjectTimeMapTimeMap');
      if (newTimeMapSelect) {
        newTimeMapSelect.innerHTML = '<option value="">Select a time map...</option>' +
          Object.entries(timeMaps).map(([id, tm]) => 
            `<option value="${escapeHtml(id)}">${escapeHtml(tm.name)}</option>`
          ).join('');
      }
    }

    // Update project time map assignment dropdown
    function updateProjectTimeMapDropdown() {
      const select = document.getElementById('newProjectTimeMapProject');
      if (!select) return;
      
      const assignedProjects = Object.keys(currentConfig.projectTimeMaps || {});
      
      select.innerHTML = '<option value="">Select a project...</option>';
      
      for (const project of availableProjects) {
        if (!assignedProjects.includes(project.id)) {
          const option = document.createElement('option');
          option.value = project.id;
          option.textContent = project.title;
          select.appendChild(option);
        }
      }
    }

    // Render project time map assignments table
    function renderProjectTimeMapAssignments() {
      ensureTimeMapsConfig();
      const tbody = document.getElementById('projectTimeMapTableBody');
      if (!tbody) return;
      
      const assignments = currentConfig.projectTimeMaps || {};
      const timeMaps = currentConfig.timeMaps || {};
      
      if (Object.keys(assignments).length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No project assignments. All projects use the default time map.</td></tr>';
        updateProjectTimeMapDropdown();
        return;
      }
      
      let html = '';
      for (const [projectId, timeMapId] of Object.entries(assignments)) {
        const project = availableProjects.find(p => p.id === projectId);
        const timeMap = timeMaps[timeMapId];
        
        if (!project || !timeMap) continue; // Skip if project or time map no longer exists
        
        html += `
          <tr>
            <td><span class="tag-badge">${escapeHtml(project.title)}</span></td>
            <td>${escapeHtml(timeMap.name)}</td>
            <td>
              <button class="btn btn-small" onclick="removeProjectTimeMapAssignment('${escapeHtml(projectId)}')">
                Remove
              </button>
            </td>
          </tr>
        `;
      }
      
      if (html === '') {
        html = '<tr><td colspan="3" style="opacity: 0.7; text-align: center;">No project assignments. All projects use the default time map.</td></tr>';
      }
      
      tbody.innerHTML = html;
      updateProjectTimeMapDropdown();
    }

    // Show modal to add a new time map
    function showAddTimeMapModal() {
      editingTimeMapId = null;
      document.getElementById('timeMapModalTitle').textContent = 'Add Time Map';
      document.getElementById('timeMapName').value = '';
      
      renderTimeMapDaysEditor(getDefaultTimeMap());
      
      document.getElementById('timeMapModal').classList.add('show');
    }

    // Show modal to edit an existing time map
    function editTimeMap(id) {
      ensureTimeMapsConfig();
      const timeMap = currentConfig.timeMaps[id];
      if (!timeMap) return;
      
      editingTimeMapId = id;
      document.getElementById('timeMapModalTitle').textContent = 'Edit Time Map';
      document.getElementById('timeMapName').value = timeMap.name;
      
      renderTimeMapDaysEditor(timeMap);
      
      document.getElementById('timeMapModal').classList.add('show');
    }

    // Render the days editor in the modal
    function renderTimeMapDaysEditor(timeMap) {
      const container = document.getElementById('timeMapDaysEditor');
      if (!container) return;
      
      let html = '';
      for (let day = 0; day < 7; day++) {
        const daySchedule = timeMap.days[day];
        const isSkip = !daySchedule;
        const startHour = daySchedule?.startHour ?? 9;
        const endHour = daySchedule?.endHour ?? 17;
        
        html += `
          <div class="day-editor-row">
            <span class="day-editor-name">${DAY_NAMES[day]}</span>
            <div class="day-editor-inputs">
              <input type="number" id="dayStart${day}" min="0" max="23" value="${startHour}" ${isSkip ? 'disabled' : ''}>
              <span>to</span>
              <input type="number" id="dayEnd${day}" min="1" max="24" value="${endHour}" ${isSkip ? 'disabled' : ''}>
              <div class="checkbox-group">
                <input type="checkbox" id="daySkip${day}" ${isSkip ? 'checked' : ''} onchange="toggleDayInputs(${day})">
                <label for="daySkip${day}">Skip</label>
              </div>
            </div>
          </div>
        `;
      }
      
      container.innerHTML = html;
    }

    // Toggle day inputs when skip checkbox changes
    function toggleDayInputs(day) {
      const skipCheckbox = document.getElementById(`daySkip${day}`);
      const startInput = document.getElementById(`dayStart${day}`);
      const endInput = document.getElementById(`dayEnd${day}`);
      
      if (skipCheckbox.checked) {
        startInput.disabled = true;
        endInput.disabled = true;
      } else {
        startInput.disabled = false;
        endInput.disabled = false;
      }
    }

    // Hide the time map modal
    function hideTimeMapModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('timeMapModal').classList.remove('show');
      editingTimeMapId = null;
    }

    // Check if two time ranges overlap
    function timeRangesOverlap(start1, end1, start2, end2) {
      return start1 < end2 && start2 < end1;
    }

    // Check if a time map overlaps with any existing time maps
    // Returns array of { dayName, existingMapName } for overlapping days
    function checkTimeMapOverlaps(newDays, excludeTimeMapId = null) {
      ensureTimeMapsConfig();
      const overlaps = [];
      
      for (const [existingId, existingMap] of Object.entries(currentConfig.timeMaps)) {
        // Skip the time map we're editing
        if (existingId === excludeTimeMapId) continue;
        
        for (let day = 0; day < 7; day++) {
          const newDay = newDays[day];
          const existingDay = existingMap.days?.[day];
          
          // Skip if either is null (skip day)
          if (!newDay || !existingDay) continue;
          
          // Check for overlap
          if (timeRangesOverlap(newDay.startHour, newDay.endHour, existingDay.startHour, existingDay.endHour)) {
            overlaps.push({
              day: day,
              dayName: DAY_NAMES[day],
              existingMapName: existingMap.name,
              existingMapId: existingId,
              newHours: `${newDay.startHour}:00-${newDay.endHour}:00`,
              existingHours: `${existingDay.startHour}:00-${existingDay.endHour}:00`
            });
          }
        }
      }
      
      return overlaps;
    }

    // Save time map from modal
    function saveTimeMap() {
      const name = document.getElementById('timeMapName').value.trim();
      if (!name) {
        showStatus('Please enter a name for the time map', 'error');
        return;
      }
      
      // Collect days data
      const days = {};
      for (let day = 0; day < 7; day++) {
        const isSkip = document.getElementById(`daySkip${day}`).checked;
        if (isSkip) {
          days[day] = null;
        } else {
          const startHour = parseInt(document.getElementById(`dayStart${day}`).value) || 9;
          const endHour = parseInt(document.getElementById(`dayEnd${day}`).value) || 17;
          
          if (endHour <= startHour) {
            showStatus(`Invalid hours for ${DAY_NAMES[day]}: end hour must be after start hour`, 'error');
            return;
          }
          
          days[day] = { startHour, endHour };
        }
      }
      
      // Check for overlaps with existing time maps
      const overlaps = checkTimeMapOverlaps(days, editingTimeMapId);
      if (overlaps.length > 0) {
        // Build a detailed error message
        const overlapDetails = overlaps.map(o => 
          `  - ${o.dayName}: ${o.newHours} overlaps with "${o.existingMapName}" (${o.existingHours})`
        ).join('\n');
        
        alert(`Cannot save time map: overlapping schedules detected!\n\n${overlapDetails}\n\nTip: If you need a task to be schedulable in multiple time windows, use Tags to assign it to multiple time maps instead of creating overlapping time maps.`);
        return;
      }
      
      ensureTimeMapsConfig();
      
      let id;
      if (editingTimeMapId) {
        // Editing existing
        id = editingTimeMapId;
        currentConfig.timeMaps[id] = { name, days };
      } else {
        // Creating new
        id = generateTimeMapId(name);
        currentConfig.timeMaps[id] = { name, days };
      }
      
      hideTimeMapModal();
      renderTimeMaps();
      renderProjectTimeMapAssignments();
      renderTagTimeMapAssignments();
      showStatus(`Time map "${name}" saved`, 'success');
    }

    // Delete a time map
    function deleteTimeMap(id) {
      ensureTimeMapsConfig();
      const timeMap = currentConfig.timeMaps[id];
      if (!timeMap) return;
      
      if (!confirm(`Delete time map "${timeMap.name}"? Projects and tags using this time map will fall back to the default.`)) {
        return;
      }
      
      // Remove from timeMaps
      delete currentConfig.timeMaps[id];
      
      // Remove from projectTimeMaps
      for (const [projectId, mapId] of Object.entries(currentConfig.projectTimeMaps)) {
        if (mapId === id) {
          delete currentConfig.projectTimeMaps[projectId];
        }
      }
      
      // Remove from tagTimeMaps
      if (currentConfig.tagTimeMaps) {
        for (const [tagId, mapId] of Object.entries(currentConfig.tagTimeMaps)) {
          if (mapId === id) {
            delete currentConfig.tagTimeMaps[tagId];
          }
        }
      }
      
      // Update default if needed
      if (currentConfig.defaultTimeMap === id) {
        currentConfig.defaultTimeMap = 'default';
      }
      
      renderTimeMaps();
      renderProjectTimeMapAssignments();
      renderTagTimeMapAssignments();
      showStatus(`Time map deleted`, 'success');
    }

    // Update default time map selection
    function updateDefaultTimeMap() {
      const select = document.getElementById('defaultTimeMapSelect');
      if (select) {
        currentConfig.defaultTimeMap = select.value;
      }
    }

    // Add a project to time map assignment
    function addProjectTimeMapAssignment() {
      const projectSelect = document.getElementById('newProjectTimeMapProject');
      const timeMapSelect = document.getElementById('newProjectTimeMapTimeMap');
      
      const projectId = projectSelect.value;
      const timeMapId = timeMapSelect.value;
      
      if (!projectId) {
        showStatus('Please select a project', 'error');
        return;
      }
      if (!timeMapId) {
        showStatus('Please select a time map', 'error');
        return;
      }
      
      ensureTimeMapsConfig();
      currentConfig.projectTimeMaps[projectId] = timeMapId;
      
      renderProjectTimeMapAssignments();
      
      // Reset selections
      projectSelect.value = '';
      timeMapSelect.value = '';
      
      const project = availableProjects.find(p => p.id === projectId);
      const timeMap = currentConfig.timeMaps[timeMapId];
      showStatus(`Assigned "${project?.title}" to "${timeMap?.name}"`, 'success');
    }

    // Remove a project time map assignment
    function removeProjectTimeMapAssignment(projectId) {
      ensureTimeMapsConfig();
      delete currentConfig.projectTimeMaps[projectId];
      renderProjectTimeMapAssignments();
    }

    // Render tag time map assignments
    function renderTagTimeMapAssignments() {
      const tbody = document.getElementById('tagTimeMapTableBody');
      const tagSelect = document.getElementById('newTagTimeMapTag');
      const timeMapSelect = document.getElementById('newTagTimeMapTimeMap');
      
      if (!tbody) return;
      
      ensureTimeMapsConfig();
      const tagTimeMaps = currentConfig.tagTimeMaps || {};
      const timeMaps = currentConfig.timeMaps || {};
      
      // Get assigned tag IDs
      const assignedTagIds = Object.keys(tagTimeMaps);
      
      // Clear and populate table
      tbody.innerHTML = '';
      
      for (const [tagId, timeMapId] of Object.entries(tagTimeMaps)) {
        const tag = availableTags.find(t => t.id === tagId);
        const timeMap = timeMaps[timeMapId];
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${tag?.title || tagId}</td>
          <td>${timeMap?.name || timeMapId}</td>
          <td>
            <button class="btn btn-small btn-danger" onclick="removeTagTimeMapAssignment('${tagId}')">Remove</button>
          </td>
        `;
        tbody.appendChild(row);
      }
      
      // Populate tag dropdown (exclude already assigned tags)
      if (tagSelect) {
        tagSelect.innerHTML = '<option value="">Select a tag...</option>';
        for (const tag of availableTags) {
          if (!assignedTagIds.includes(tag.id)) {
            const option = document.createElement('option');
            option.value = tag.id;
            option.textContent = tag.title;
            tagSelect.appendChild(option);
          }
        }
      }
      
      // Populate time map dropdown
      if (timeMapSelect) {
        timeMapSelect.innerHTML = '<option value="">Select a time map...</option>';
        for (const [id, timeMap] of Object.entries(timeMaps)) {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = timeMap.name || id;
          timeMapSelect.appendChild(option);
        }
      }
    }

    // Add a tag to time map assignment
    function addTagTimeMapAssignment() {
      const tagSelect = document.getElementById('newTagTimeMapTag');
      const timeMapSelect = document.getElementById('newTagTimeMapTimeMap');
      
      const tagId = tagSelect.value;
      const timeMapId = timeMapSelect.value;
      
      if (!tagId) {
        showStatus('Please select a tag', 'error');
        return;
      }
      if (!timeMapId) {
        showStatus('Please select a time map', 'error');
        return;
      }
      
      ensureTimeMapsConfig();
      if (!currentConfig.tagTimeMaps) {
        currentConfig.tagTimeMaps = {};
      }
      currentConfig.tagTimeMaps[tagId] = timeMapId;
      
      renderTagTimeMapAssignments();
      
      // Reset selections
      tagSelect.value = '';
      timeMapSelect.value = '';
      
      const tag = availableTags.find(t => t.id === tagId);
      const timeMap = currentConfig.timeMaps[timeMapId];
      showStatus(`Assigned "${tag?.title}" to "${timeMap?.name}"`, 'success');
    }

    // Remove a tag time map assignment
    function removeTagTimeMapAssignment(tagId) {
      ensureTimeMapsConfig();
      if (currentConfig.tagTimeMaps) {
        delete currentConfig.tagTimeMaps[tagId];
      }
      renderTagTimeMapAssignments();
    }

    // ============================================================================
    // END TIME MAPS MANAGEMENT
    // ============================================================================

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadSettings();
    });

    // Also try to load immediately in case DOMContentLoaded already fired
    if (document.readyState !== 'loading') {
      loadSettings();
    }
  </script>

  <!-- Clear Planning Confirmation Modal -->
  <div id="clearPlanningModal" class="modal-overlay" onclick="hideClearPlanningModal(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <div class="modal-title">Clear All Planning?</div>
      <div class="modal-body">
        <p>This will:</p>
        <ul>
          <li>Merge all split tasks back together</li>
          <li>Remove scheduled times from tasks with time estimates</li>
        </ul>
        <p><strong>Note:</strong> Tasks with "Do Not Reschedule" tag are not affected.</p>
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="hideClearPlanningModal()">Cancel</button>
        <button class="btn btn-danger" onclick="confirmClearPlanning()">Clear Planning</button>
      </div>
    </div>
  </div>

  <!-- Time Map Editor Modal -->
  <div id="timeMapModal" class="modal-overlay" onclick="hideTimeMapModal(event)">
    <div class="modal" style="max-width: 500px;" onclick="event.stopPropagation()">
      <div class="modal-title" id="timeMapModalTitle">Add Time Map</div>
      <div class="modal-body">
        <div class="form-group">
          <label for="timeMapName">Time Map Name</label>
          <input type="text" id="timeMapName" placeholder="e.g., Work Hours, Evenings, Weekends">
        </div>
        
        <div class="form-group">
          <label>Schedule per Day</label>
          <p class="help-text" style="margin-bottom: 8px;">Set start and end hours for each day, or check "Skip" to not schedule on that day.</p>
          
          <div id="timeMapDaysEditor">
            <!-- Days will be populated dynamically -->
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="hideTimeMapModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveTimeMap()">Save</button>
      </div>
    </div>
  </div>
</body>
</html>
